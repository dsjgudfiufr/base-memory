---
name: bitable-memory
description: Use Feishu Bitable as an AI agent's external brain — task management, execution logs, and long-term memory. Activate when managing tasks, logging findings, or storing memories in Bitable.
---

# Bitable Memory — 飞书多维表格作为 AI Agent 外脑

> 上下文窗口 = RAM（易失、有限）。Bitable = Disk（持久、无限）。

## Setup

First-time setup: run `bt setup` to create tables and generate config.

```bash
# Set credentials (or pass via config)
export FEISHU_APP_ID="your_app_id"
export FEISHU_APP_SECRET="your_app_secret"

# Initialize: creates 3 tables in a new or existing Bitable
python3 scripts/bt setup [--app-token EXISTING_APP_TOKEN]
# → Generates bitable_config.json with table IDs and field IDs
# → Creates: 任务表 / 执行日志表 / 记忆库
```

## Architecture: Three Tables

| Table | Purpose | Analogy |
|-------|---------|---------|
| **任务表** (tasks) | Task status snapshots — goal, phase, progress | `task_plan.md` |
| **执行日志表** (logs) | Process notes — findings, decisions, errors | `findings.md` + `progress.md` |
| **记忆库** (memory) | Long-term memory — cross-task lessons | Persistent knowledge base |

## Core Commands

### Task Management

```bash
bt task add "Task name" [-p 紧急|重要|普通] [-i "original instruction"]
bt task done <ID> [-s "result summary"]
bt task phase <ID> "阶段2-实现"
bt task show <ID>              # Re-read goal + plan (attention refresh)
bt task ls [--all]             # List active tasks
bt task next                   # Scheduler: what should I do now?
bt task resume                 # 5-question restart check
bt task block <ID> -r "reason"
bt task interrupt <ID> -m "breakpoint description"
bt task search <keyword>
```

### Subtasks (inline, no separate rows)

```bash
bt task add "Subtask A" --parent <PARENT_ID>
bt subtask phase <PARENT_ID> "Subtask A" "Phase description"
bt subtask done <PARENT_ID> "Subtask A" -s "summary"
# Last subtask done → parent auto-completes
```

### Execution Logs (context offloading)

```bash
bt log add <ID> plan "Goal: ... Phases: ... Key questions: ..."
bt log add <ID> finding "Discovery: ..."
bt log add <ID> decision "Decision: A not B, reason: ..."
bt log add <ID> error "Error: ... Cause: ... Fix: ..."
bt log add <ID> resource "URL or file path"
bt log add <ID> milestone "Phase N complete: ..."
bt log add <ID> progress "What was done" --phase "Phase N"
bt log ls <ID> [--type finding] [--last 10]
bt log search <keyword>
```

### Memory (long-term)

```bash
bt mem add "Title" "Content" [-t type]
bt mem ls [--type 教训]
bt mem search <keyword>
```

## Built-in Safeguards

1. **Content truncation** — `bt log add` auto-truncates at 500 chars, warns to use `--file`
2. **Attention refresh** — Every 10 logs, reminds to `bt task show` (prevents drift)
3. **Plan-first check** — Warns if logging before writing a plan
4. **Error protocol** — Tracks error count; must change approach before retrying
5. **Completion check** — `bt task done` warns if plan or milestone logs are missing

## Workflow Rules

### Task Reception

```
Receive instruction → bt task add → bt task phase → bt log add plan → execute
```

### Two-Action Rule (mandatory)

Every 2 search/browse/read operations → immediately `bt log add finding`. Don't batch.

### Visual Content Rule

See image/screenshot/PDF → immediately `bt log add finding` to textualize. Multimodal content doesn't persist.

### Context Offloading

Tool output stays in context only as: `"Written to log table recXXX"`. The actual content lives in Bitable.

### Error Protocol

```
Fail #1 → diagnose, change approach → bt log add error
Fail #2 → completely different method → bt log add error
Fail #3+ → same pattern
Fail #5 → escalate to human
```

**Iron rule: never repeat the same failed action.**

### Phase Transitions

```bash
bt task phase <ID> "Phase 2"
bt log add <ID> milestone "Phase 1 complete: ..."
bt task next    # Interrupt check: higher priority task?
```

## Configuration

`bitable_config.json` (generated by `bt setup`):

```json
{
  "app_token": "...",
  "tables": {
    "tasks": { "id": "tblXXX", "fields": { "任务名称": "fldXXX", ... } },
    "logs":  { "id": "tblXXX", "fields": { "内容": "fldXXX", ... } },
    "memory": { "id": "tblXXX", "fields": { "标题": "fldXXX", ... } }
  }
}
```

Credentials: set `FEISHU_APP_ID` + `FEISHU_APP_SECRET` env vars, or pass via config.

## Workflow Rules

For the complete task execution methodology (Manus context engineering adapted for Bitable), see [references/workflow-rules.md](references/workflow-rules.md). Key rules:

- **Task reception**: classify message → task or conversation → only tasks go to Bitable
- **Plan first**: always `bt log add plan` before executing
- **Two-action rule**: every 2 search/browse ops → immediately `bt log add finding`
- **Context offloading**: tool output → log table, not context window
- **Error protocol**: must change approach before retrying; 5 failures → auto-block
- **Attention refresh**: `bt task show` every 10 tool calls or before major decisions


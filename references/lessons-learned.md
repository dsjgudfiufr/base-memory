# 📚 经验教训 — 通用 Base 任务管理踩坑记录

> 从实际使用中提炼的通用经验，帮助新 agent 避免重复踩坑。

## Base API 操作经验

### 一致性延迟
- Base 写入后立即读取可能读到旧数据（1-2 秒延迟）
- 自动化测试中需要加 `sleep(2)` 再验证写入结果
- 不要依赖"写完立刻读"来确认状态

### 字段类型转换
- 飞书数字字段 API 返回的是**字符串**，需要 `int(float(val))` 转换
- 日期字段公式里单位是"天"（类似 Excel），写入时用 ms 时间戳
- 布尔字段返回 `true/false`，不是 `1/0`

### page_size 不可靠
- `page_size` 参数不能用于精确截断（实际返回数量可能不等于请求数量）
- 需要精确数量时，用客户端切片：请求多一些，本地 `.slice(0, N)`

### 搜索 API 注意事项
- `searchRecords` 的 filter 条件中，字段名必须用**显示名**（不是 field_id）
- 排序字段同理，用显示名
- 多条件用 `conjunction: "and"` 或 `"or"` 包装

## 飞书消息发送注意事项

### 审计拦截
- 飞书审计会拦截包含敏感信息的消息（如邮箱地址）
- 错误码 `230028 contain sensitive data: EMAIL_ADDRESS`
- 发送前检查内容，必要时用占位符替换敏感信息

### Post 消息格式
- 发送 post 类型消息时，content 必须包含语言包装层：
```json
{
  "zh_cn": {
    "title": "",
    "content": [[{"tag": "text", "text": "..."}]]
  }
}
```
- ❌ 错误：`{"title": "", "content": [...]}` → 400 报错（230001）
- ✅ 正确：`{"zh_cn": {"title": "", "content": [...]}}`

### 消息可靠性
- 回复延迟时，用飞书 API 直接发消息更可靠（绕过中间层回复队列）
- Bot 发的 interactive card（v1 格式）无法通过 API 读取实际内容（234043）

## 父子任务操作经验

### 内联模式
- 子任务不建独立 Base 行，写入父任务行的字段中
- 日志直接用父任务 ID：`bm log add <父ID> finding/decision/error`
- 子任务无独立 record ID

### 自动完成机制
- 最后一个子任务 `bm subtask done` → 父任务自动标记完成
- **必须先建所有子任务，再逐步 done**（否则父任务提前自动完成）

### 误完成恢复
- 父任务被误标记完成时：更新状态字段为 `🔄进行中` + API PUT null 清除完成时间
- 这是代码驱动的行为，不是 Base 自动化规则

### 子任务进度更新
- `bm subtask phase <父ID> "子任务名" "阶段描述"` — 更新任务进展字段
- `bm subtask done <父ID> "子任务名" -s "摘要"` — 打 ✅ + 指向下一个 + 写 milestone

## 错误处理经验

### 核心原则：不重复失败动作
- 每次失败后**必须改变方法**，不允许用完全相同的方式再试
- 错误次数由系统自动计数，第 5 次自动 block
- 门禁机制：系统检查是否已改变方法，才允许再次尝试

### 改变方法的策略
- 换 API 端点或参数
- 换实现思路（如从 API 改为直接操作文件）
- 分解为更小的步骤
- 查文档确认正确用法后再试

## 进度可见性经验

### 逐个推进，不批量操作
- 子任务必须逐个推进：开始时 `bm subtask phase`，完成时 `bm subtask done`
- **绝不批量操作**（用户会观察到进度从开始直接跳到完成，中间无变化）
- 进度可见性很重要：用户会实时观察多维表格，中间状态必须可见

### Sub-Agent 模式下的进度
- 主 session 负责 `subtask phase`（开始标记）
- Sub-agent 负责 `subtask done`（完成标记）
- 这样用户能看到每个子任务的实时状态变化

## 上下文管理经验

### Compaction 后恢复
- 上下文被压缩后，之前的工具输出会丢失
- 恢复方法：`bm task resume`（5问重启检查）
- 从任务表和日志表重建上下文，不依赖内存

### Token 快照
- 建任务后立刻记录 token 快照，用于监控上下文消耗
- 任务完成时再记录一次，对比消耗量
- 帮助优化上下文使用效率

### 上下文卸载
- 工具返回的大内容不要留在上下文中
- 立刻写入日志表，上下文只保留一句话引用
- 丢弃大内容前**必须先保留指针**（URL 或文件路径）

## CLI 系统操作经验

### 任务表字段设计
- 任务表只需两个核心展示字段：**任务进展**（静态）+ **任务进展**（动态）
- `bm log add plan` 同时写日志表 + 任务表「任务进展」字段
- `bm task add --parent` 把子任务名追加到任务进展的 `子任务：A → B → C` 行

### Plan 检查优化
- plan 检查改为本地缓存（`.bm_state.json`），每次 `bm log add` 省一次 search API
- 避免频繁查询 Base 来确认是否已写 plan

### 内建安全机制
- 内容超 500 字自动截断 + 警告
- 每 10 条日志提醒 `bm task show`（注意力刷新）
- 写入成功后输出"上下文已卸载到 Base"
- 非 plan 类型时检查是否已写 plan
- `bm task done` 检查 plan + milestone 完整性

#!/usr/bin/env python3
"""
bm - Base Memory CLI (AI Agent å¤–è„‘)
ç”¨æ³•:
  bm task add <åç§°> [-p ç´§æ€¥|é‡è¦|æ™®é€š] [-i "åŸå§‹æŒ‡ä»¤"]
  bm task done <id> [-t tokenæ•°] [-s "ç»“æœæ‘˜è¦"]
  bm task up <id> <å­—æ®µå> <æ–°å€¼>
  bm task ls [--all | --status è¿›è¡Œä¸­]
  bm task resume
  bm task search <å…³é”®è¯>
  bm task block <id> -r "é˜»å¡åŸå› "
  bm task show <id>
  bm mem add <æ ‡é¢˜> <å†…å®¹> [-t çŸ¥è¯†|æ•™è®­|åå¥½|ä¸Šä¸‹æ–‡] [-i æ ¸å¿ƒ|é‡è¦|æ™®é€š]
  bm mem ls
  bm mem search <å…³é”®è¯>
"""

import json, urllib.request, sys, os, time, argparse
from datetime import datetime

# â”€â”€ é…ç½® â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))  # è·Ÿéš symlink æ‰¾çœŸå®è·¯å¾„
CONFIG_FILE = os.path.join(SCRIPT_DIR, 'base_config.json')
OPENCLAW_CONFIG = os.environ.get('OPENCLAW_CONFIG', os.path.expanduser('~/.openclaw/openclaw.json'))
MAX_ERROR_RETRIES = int(os.environ.get('BT_MAX_ERROR_RETRIES', '5'))
OWNER_OPEN_ID = os.environ.get('BT_OWNER_OPEN_ID', '')  # Owner's Feishu open_id (for notifications)

# â”€â”€ ANSI é¢œè‰² â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class C:
    RESET  = '\033[0m'
    BOLD   = '\033[1m'
    RED    = '\033[91m'
    GREEN  = '\033[92m'
    YELLOW = '\033[93m'
    BLUE   = '\033[94m'
    CYAN   = '\033[96m'
    GRAY   = '\033[90m'
    WHITE  = '\033[97m'

def c(color, text): return f'{color}{text}{C.RESET}'
def ok(msg):   print(c(C.GREEN,  f'âœ… {msg}'))
def err(msg):  print(c(C.RED,    f'âŒ {msg}')); sys.exit(1)
def info(msg): print(c(C.CYAN,   f'â„¹  {msg}'))
def warn(msg): print(c(C.YELLOW, f'âš   {msg}'))
def hr():      print(c(C.GRAY, 'â”€' * 60))

# â”€â”€ API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_token_cache = {'val': None, 'exp': 0}

def get_token():
    if _token_cache['val'] and time.time() < _token_cache['exp']:
        return _token_cache['val']
    with open(OPENCLAW_CONFIG) as f:
        cfg = json.load(f)
    acc = cfg['channels']['feishu']['accounts']['main']
    req = urllib.request.Request(
        'https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal',
        data=json.dumps({'app_id': acc['appId'], 'app_secret': acc['appSecret']}).encode(),
        headers={'Content-Type': 'application/json'}
    )
    r = json.loads(urllib.request.urlopen(req).read())
    _token_cache['val'] = r['tenant_access_token']
    _token_cache['exp'] = time.time() + r.get('expire', 7200) - 60
    return _token_cache['val']

def api(method, path, body=None):
    token = get_token()
    url = f'https://open.feishu.cn/open-apis{path}'
    data = json.dumps(body, ensure_ascii=False).encode() if body else None
    req = urllib.request.Request(url, data=data, method=method,
        headers={'Content-Type': 'application/json; charset=utf-8',
                 'Authorization': f'Bearer {token}'})
    try:
        return json.loads(urllib.request.urlopen(req).read())
    except urllib.error.HTTPError as e:
        try:    return json.loads(e.read())
        except: return {'code': e.code, 'msg': str(e)}

def cfg():
    with open(CONFIG_FILE) as f:
        return json.load(f)

# â”€â”€ å­—æ®µå€¼æå– â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def fv(fields, key, truncate=None):
    """æå–å­—æ®µå€¼ä¸ºå­—ç¬¦ä¸²"""
    val = fields.get(key)
    if val is None: return ''
    if isinstance(val, list):
        text = ''.join(i.get('text', '') if isinstance(i, dict) else str(i) for i in val)
    elif isinstance(val, bool):
        text = 'âœ…' if val else 'â˜'
    elif isinstance(val, (int, float)):
        if key in ('åˆ›å»ºæ—¶é—´','å¼€å§‹æ‰§è¡Œæ—¶é—´','å®Œæˆæ—¶é—´','è®°å½•æ—¶é—´'):
            try: text = datetime.fromtimestamp(val/1000).strftime('%m-%d %H:%M')
            except: text = str(val)
        else:
            text = str(int(val)) if float(val) == int(val) else str(val)
    else:
        text = str(val)
    if truncate and len(text) > truncate:
        text = text[:truncate] + 'â€¦'
    return text

def search_records(table_id, filter_body=None):
    c = cfg()
    body = {'page_size': 100}
    if filter_body: body.update(filter_body)
    r = api('POST', f'/bitable/v1/apps/{c["app_token"]}/tables/{table_id}/records/search', body)
    if r.get('code', 0) != 0:
        warn(f'search_records å¤±è´¥: [{r.get("code")}] {r.get("msg")}')
        return []
    return r.get('data', {}).get('items', [])

# æ‰§è¡Œåºå·å’Œåˆ›å»ºæ—¶é—´å‡ç”±é£ä¹¦è‡ªåŠ¨å¡«å†™ï¼Œæ— éœ€è®¡ç®—

# â”€â”€ STATUS æ ·å¼æ˜ å°„ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
STATUS_COLOR = {
    'ğŸ• å¾…å¼€å§‹': C.GRAY,
    'ğŸ”„ è¿›è¡Œä¸­': C.BLUE,
    'ğŸš§ é˜»å¡ä¸­': C.YELLOW,
    'â¸ï¸ å·²æš‚åœ': C.CYAN,
    'âœ… å·²å®Œæˆ': C.GREEN,
    'âŒ å·²å–æ¶ˆ': C.RED,
}
PRIORITY_COLOR = {
    'ğŸ”´ ç´§æ€¥': C.RED,
    'ğŸŸ¡ é‡è¦': C.YELLOW,
    'ğŸŸ¢ æ™®é€š': C.GREEN,
}

def fmt_status(s):
    color = STATUS_COLOR.get(s, C.RESET)
    return c(color, s)

def fmt_priority(p):
    color = PRIORITY_COLOR.get(p, C.RESET)
    return c(color, p)

# â”€â”€ æ‰“å°ä»»åŠ¡ï¼ˆå•è¡Œç®€æ´ç‰ˆï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def print_task_line(rec):
    f = rec.get('fields', {})
    rid = rec.get('record_id', '')
    seq  = fv(f, 'æ‰§è¡Œåºå·') or '-'
    name = fv(f, 'ä»»åŠ¡åç§°', truncate=30)
    status   = fv(f, 'çŠ¶æ€')
    priority = fv(f, 'ä¼˜å…ˆçº§')
    phase = fv(f, 'ä»»åŠ¡è¿›å±•', truncate=20)
    summary = fv(f, 'ç»“æœæ‘˜è¦', truncate=40)
    display_note = phase or summary
    err_cnt = f.get('é”™è¯¯æ¬¡æ•°')
    err_tag = ''
    if err_cnt:
        n = int(float(err_cnt))
        if n > 0:
            err_tag = c(C.RED if n >= MAX_ERROR_RETRIES else C.YELLOW, f' âŒ{n}')
    print(f"  {c(C.GRAY,'#'+seq):6s} {fmt_status(status):20s} {fmt_priority(priority):12s} "
          f"{c(C.WHITE, name):35s}{err_tag}")
    if display_note:
        print(f"          {c(C.GRAY,'â–¶')} {c(C.CYAN, display_note)}")
    print(f"          {c(C.GRAY, rid)}")

# â”€â”€ æ‰“å°ä»»åŠ¡ï¼ˆè¯¦æƒ…ç‰ˆï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def print_task_detail(rec):
    f = rec.get('fields', {})
    rid = rec.get('record_id', '')
    hr()
    print(f"{c(C.BOLD+C.WHITE, fv(f,'ä»»åŠ¡åç§°'))}  {c(C.GRAY, rid)}")
    err_cnt = f.get('é”™è¯¯æ¬¡æ•°')
    err_str = ''
    if err_cnt:
        n = int(float(err_cnt))
        if n > 0:
            err_color = C.RED if n >= MAX_ERROR_RETRIES else C.YELLOW
            err_str = f'  {c(err_color, f"âŒ{n}æ¬¡é”™è¯¯")}'
    print(f"  çŠ¶æ€: {fmt_status(fv(f,'çŠ¶æ€'))}  "
          f"ä¼˜å…ˆçº§: {fmt_priority(fv(f,'ä¼˜å…ˆçº§'))}  "
          f"åºå·: #{fv(f,'æ‰§è¡Œåºå·') or '-'}{err_str}")
    for key, label in [
        ('ä»»åŠ¡è¿›å±•',   'ğŸ“ ä»»åŠ¡è¿›å±•'),
    ]:
        v = fv(f, key)
        if v: print(f"  {label}: {c(C.CYAN, v[:120])}")
    # ä»»åŠ¡è¿›å±•
    plan = fv(f, 'ä»»åŠ¡è¿›å±•')
    if plan:
        print(f"\n  {c(C.BOLD, 'ğŸ“‹ ä»»åŠ¡è¿›å±•')}:")
        for line in plan[:400].replace('\\n', '\n').split('\n'):
            if not line.strip(): continue
            print(f"    {c(C.BLUE, line.strip())}")
    # æ—¶é—´è¡Œ
    times = []
    for k, l in [('åˆ›å»ºæ—¶é—´','åˆ›å»º'),('å¼€å§‹æ‰§è¡Œæ—¶é—´','å¼€å§‹'),('å®Œæˆæ—¶é—´','å®Œæˆ')]:
        v = fv(f, k)
        if v: times.append(f'{l}:{v}')
    if times: print(f"  {c(C.GRAY, '  '.join(times))}")
    # æ—¶é•¿
    dur = fv(f, 'æ‰§è¡Œæ—¶é•¿ï¼ˆç§’ï¼Œè‡ªåŠ¨ï¼‰')
    tok = fv(f, 'Token å¼€é”€')
    if dur or tok:
        parts = []
        if dur: parts.append(f'æ—¶é•¿:{dur}s')
        if tok: parts.append(f'Token:{tok}')
        print(f"  {c(C.GRAY, '  '.join(parts))}")
    # å¤šè¡Œå­—æ®µ
    for key, label, color in [
        ('åŸå§‹æŒ‡ä»¤',   'ğŸ“‹ åŸå§‹æŒ‡ä»¤',   C.GRAY),
        ('ç»“æœæ‘˜è¦',   'ğŸ ç»“æœæ‘˜è¦',   C.GREEN),
    ]:
        v = fv(f, key)
        if v:
            lines = v[:600].split('\n')
            print(f"\n  {c(C.GRAY, label)}:")
            for line in lines[:12]:
                print(f"    {c(color, line)}")

# â”€â”€ è°ƒåº¦è§¦å‘ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _trigger_dispatch():
    """åå°è§¦å‘ bm-dispatch.mjs --onceï¼Œä¸é˜»å¡å½“å‰å‘½ä»¤"""
    import subprocess
    trigger_script = os.path.realpath(os.path.join(SCRIPT_DIR, 'bm-dispatch-trigger.sh'))
    if os.path.exists(trigger_script):
        try:
            subprocess.Popen(
                ['bash', trigger_script],
                start_new_session=True
            )
        except Exception:
            pass  # è°ƒåº¦å¤±è´¥ä¸å½±å“ bm å‘½ä»¤æœ¬èº«

# â”€â”€ TASK å­å‘½ä»¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _auto_recall(c_, keywords, context='task'):
    """è‡ªåŠ¨å¬å›ï¼šç”¨å…³é”®è¯æœç´¢æ—¥å¿—è¡¨+è®°å¿†åº“ï¼Œå±•ç¤ºç›¸å…³å†å²ç»éªŒ"""
    log_table = c_['tables']['logs']['id']
    mem_table = c_['tables']['memory']['id']
    task_table = c_['tables']['tasks']['id']
    hits = []

    # æœç´¢æ‰§è¡Œæ—¥å¿—è¡¨ï¼ˆæœåŠ¡ç«¯ containsï¼‰
    for kw in keywords[:3]:  # æœ€å¤šç”¨3ä¸ªå…³é”®è¯
        if len(kw) < 2: continue
        recs = search_records(log_table, {
            'filter': {'conjunction': 'and', 'conditions': [
                {'field_name': 'å†…å®¹', 'operator': 'contains', 'value': [kw]}
            ]},
            'sort': [{'field_name': 'è®°å½•æ—¶é—´', 'desc': True}],
            'field_names': ['å†…å®¹', 'å…³è”ä»»åŠ¡ID', 'ç±»å‹'],
            'page_size': 5
        })
        for r in recs:
            rid = r.get('record_id', '')
            if rid not in [h[0] for h in hits]:
                hits.append((rid, 'log', r.get('fields', {}), kw))

    # æœç´¢è®°å¿†åº“ï¼ˆæœåŠ¡ç«¯ containsï¼‰
    for kw in keywords[:3]:
        if len(kw) < 2: continue
        recs = search_records(mem_table, {
            'filter': {'conjunction': 'and', 'conditions': [
                {'field_name': 'å†…å®¹', 'operator': 'contains', 'value': [kw]},
                {'field_name': 'æ˜¯å¦æ¿€æ´»', 'operator': 'is', 'value': [True]}
            ]},
            'field_names': ['æ ‡é¢˜', 'å†…å®¹', 'ç±»å‹'],
            'page_size': 5
        })
        for r in recs:
            rid = r.get('record_id', '')
            if rid not in [h[0] for h in hits]:
                hits.append((rid, 'mem', r.get('fields', {}), kw))

    if not hits:
        return

    # å»é‡åæœ€å¤šå±•ç¤º 5 æ¡ï¼Œè¾“å‡ºç²¾ç®€æ‘˜è¦ï¼ˆä¸å±•å¼€å†…å®¹ï¼ŒèŠ‚çœ tokenï¼‰
    hits = hits[:5]
    log_count = sum(1 for _, s, _, _ in hits if s == 'log')
    mem_count = sum(1 for _, s, _, _ in hits if s == 'mem')
    parts = []
    if log_count: parts.append(f'æ—¥å¿— {log_count} æ¡')
    if mem_count: parts.append(f'è®°å¿† {mem_count} æ¡')
    print(f'  ğŸ“– è‡ªåŠ¨å¬å›ï¼šæ‰¾åˆ° {len(hits)} æ¡ç›¸å…³è®°å½•ï¼ˆ{"ã€".join(parts)}ï¼‰')
    print(f'  {c(C.GRAY, "ï¼ˆæŸ¥çœ‹è¯¦æƒ…ï¼šbm log search <å…³é”®è¯>ï¼‰")}'  )


def _extract_keywords(text):
    """ä»ä»»åŠ¡å/æŒ‡ä»¤ä¸­æå–æœç´¢å…³é”®è¯ï¼ˆç®€å•åˆ†è¯ï¼‰"""
    import re
    # å»æ‰å¸¸è§åœç”¨è¯å’Œæ ‡ç‚¹
    stop = {'çš„', 'äº†', 'åœ¨', 'æ˜¯', 'å’Œ', 'ä¸', 'æŠŠ', 'å°†', 'å¯¹', 'ä»', 'åˆ°', 'ç”¨',
            'ä¸º', 'è¢«', 'è®©', 'ç»™', 'æŒ‰', 'è¦', 'èƒ½', 'å¯ä»¥', 'éœ€è¦', 'è¿›è¡Œ', 'å®ç°',
            'ä¼˜åŒ–', 'ä¿®å¤', 'æ·»åŠ ', 'æ›´æ–°', 'å®Œæˆ', 'å¤„ç†', 'æ”¯æŒ', 'ä½¿ç”¨', 'åŠŸèƒ½'}
    # æŒ‰ä¸­æ–‡/è‹±æ–‡/æ•°å­—åˆ†è¯
    tokens = re.findall(r'[\u4e00-\u9fff]{2,}|[a-zA-Z_]{3,}|[a-zA-Z_]+[0-9]+', text)
    keywords = [t for t in tokens if t.lower() not in stop and len(t) >= 2]
    # å»é‡ä¿åº
    seen = set()
    result = []
    for k in keywords:
        if k.lower() not in seen:
            seen.add(k.lower())
            result.append(k)
    return result[:5]


def task_add(args):
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    now_ms = int(time.time() * 1000)
    priority_map = {'ç´§æ€¥': 'ğŸ”´ ç´§æ€¥', 'é‡è¦': 'ğŸŸ¡ é‡è¦', 'æ™®é€š': 'ğŸŸ¢ æ™®é€š'}
    priority = priority_map.get(args.priority, args.priority)
    if not any(priority.startswith(p) for p in ['ğŸ”´','ğŸŸ¡','ğŸŸ¢']):
        priority = 'ğŸŸ¢ æ™®é€š'
    # åˆ›å»ºæ—¶é—´å’Œæ‰§è¡Œåºå·ç”±é£ä¹¦è‡ªåŠ¨å¡«å†™ï¼Œä¸éœ€è¦ä¼ 
    fields = {
        'ä»»åŠ¡åç§°':     args.name,
        'çŠ¶æ€':        'ğŸ”„ è¿›è¡Œä¸­',
        'ä¼˜å…ˆçº§':      priority,
        'å¼€å§‹æ‰§è¡Œæ—¶é—´': now_ms,   # ä»»åŠ¡å¯åŠ¨æ—¶åˆ»ï¼ˆä¸åŒäºåˆ›å»ºæ—¶é—´ï¼‰
        # ä»»åŠ¡è¿›å±•ç”± dispatch è‡ªåŠ¨è§„åˆ’å¡«å†™ï¼Œå»ºä»»åŠ¡æ—¶ç•™ç©º
    }
    if args.instruction: fields['åŸå§‹æŒ‡ä»¤'] = args.instruction
    # â”€â”€ çˆ¶ä»»åŠ¡ï¼šå­ä»»åŠ¡å†…è”æ¨¡å¼ï¼ˆæ–¹æ¡ˆAï¼šä¸å»ºç‹¬ç«‹è¡Œï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if args.parent:
        pr = api('GET', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{args.parent}')
        if pr.get('code') != 0:
            err(f'çˆ¶ä»»åŠ¡ {args.parent} ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥IDæ˜¯å¦æ­£ç¡®')
        pf = pr['data']['record']['fields']
        pstatus = fv(pf, 'çŠ¶æ€')
        if pstatus == 'âœ… å·²å®Œæˆ':
            warn(f'çˆ¶ä»»åŠ¡å·²å®Œæˆï¼å»ºè®®ç¡®è®¤æ˜¯å¦è¦åœ¨å·²å…³é—­çš„ä»»åŠ¡ä¸‹åˆ›å»ºå­ä»»åŠ¡ã€‚')
        # è¿½åŠ å­ä»»åŠ¡ååˆ°ã€Œä»»åŠ¡è¿›å±•ã€å­—æ®µ
        current_plan = fv(pf, 'ä»»åŠ¡è¿›å±•') or ''
        if current_plan and 'å­ä»»åŠ¡ï¼š' not in current_plan:
            # ç¬¬ä¸€æ¬¡åŠ å­ä»»åŠ¡ï¼Œè¿½åŠ å­ä»»åŠ¡æ®µè½
            new_plan = current_plan.rstrip() + f'\nå­ä»»åŠ¡ï¼š{args.name}'
        elif 'å­ä»»åŠ¡ï¼š' in current_plan:
            # å·²æœ‰å­ä»»åŠ¡æ®µè½ï¼Œè¿½åŠ 
            new_plan = current_plan.rstrip() + f' â†’ {args.name}'
        else:
            new_plan = f'å­ä»»åŠ¡ï¼š{args.name}'
        # ä»»åŠ¡è¿›å±•æŒ‡å‘ç¬¬ä¸€ä¸ªå­ä»»åŠ¡ï¼ˆå¦‚æœè¿˜æ²¡å¼€å§‹ï¼‰
        phase = fv(pf, 'ä»»åŠ¡è¿›å±•') or ''
        if not phase or phase == 'é˜¶æ®µ1-éœ€æ±‚æ¢ç´¢':
            phase = f'ğŸ“{args.name}ï¼šå¾…å¼€å§‹'
        api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{args.parent}',
            {'fields': {'ä»»åŠ¡è¿›å±•': new_plan, 'ä»»åŠ¡è¿›å±•': phase}})
        ok(f'å­ä»»åŠ¡å·²æ·»åŠ åˆ°çˆ¶ä»»åŠ¡è¡Œ')
        print(f"   {c(C.WHITE, args.name)}")
        print(f"   {c(C.GRAY, 'â†³ çˆ¶ä»»åŠ¡:')} {c(C.CYAN, args.parent)}")
        done_hint = f'å®Œæˆæ—¶è¿è¡Œ: bm subtask done {args.parent} "{args.name}"'
        print(f"\n   {c(C.GRAY, done_hint)}")
        return

    # â”€â”€ æ™®é€šä»»åŠ¡ï¼šåˆ›å»ºç‹¬ç«‹è¡Œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    r = api('POST', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records',
        {'fields': fields})
    if r.get('code') == 0:
        rid = r['data']['record']['record_id']
        ok(f'ä»»åŠ¡å·²åˆ›å»º  {rid}')
        print(f"   {c(C.WHITE, args.name)}")
        print(f"   {fmt_priority(priority)}  {c(C.GRAY, datetime.now().strftime('%H:%M:%S'))}")
        print(f"\n   {c(C.GRAY, f'å®Œæˆæ—¶è¿è¡Œ: bm task done {rid}')}")
        # â”€â”€ ä»»ä½•æ–°ä»»åŠ¡åŠ å…¥åï¼šè¿è¡Œè°ƒåº¦å™¨ç»™å‡ºå»ºè®® â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        print()
        class _A: pass
        task_next(_A())
        # â”€â”€ ManusåŸåˆ™ï¼šè‡ªåŠ¨å¬å›ç›¸å…³å†å²ç»éªŒ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        search_text = args.name + ' ' + (args.instruction or '')
        keywords = _extract_keywords(search_text)
        if keywords:
            _auto_recall(c_, keywords)
        # â”€â”€ ç´§æ€¥ä»»åŠ¡ï¼šç«‹å³è§¦å‘è°ƒåº¦ï¼ˆè‡ªåŠ¨ä¸­æ–­ä½ä¼˜å…ˆçº§ä»»åŠ¡ï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if priority.startswith('ğŸ”´'):
            pass  # dispatch ç”±å¿ƒè·³é©±åŠ¨
    else:
        err(f'åˆ›å»ºå¤±è´¥: {r.get("msg")}')

def _show_next_tasks(c_):
    """å®Œæˆä»»åŠ¡åï¼Œè‡ªåŠ¨å±•ç¤ºå¾…å¼€å§‹/è¿›è¡Œä¸­/æš‚åœ/é˜»å¡ä¸­çš„ä»»åŠ¡"""
    table_id = c_['tables']['tasks']['id']
    r = api('POST', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/search', {
        'filter': {'conjunction': 'or', 'conditions': [
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸ• å¾…å¼€å§‹']},
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸ”„ è¿›è¡Œä¸­']},
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['â¸ï¸ å·²æš‚åœ']},
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸš§ é˜»å¡ä¸­']},
        ]},
        'sort': [{'field_name': 'æ‰§è¡Œåºå·', 'desc': False}],
        'field_names': ['ä»»åŠ¡åç§°', 'çŠ¶æ€', 'ä¼˜å…ˆçº§', 'æ‰§è¡Œåºå·', 'ä»»åŠ¡è¿›å±•', 'é”™è¯¯æ¬¡æ•°'],
        'page_size': 5
    })
    items = r.get('data', {}).get('items', [])
    if not items:
        print(c(C.GREEN, '\nğŸ‰ æ²¡æœ‰å¾…å¤„ç†ä»»åŠ¡ï¼Œå…¨éƒ¨å®Œæˆï¼'))
        return
    # åªå±•ç¤ºæœ€é«˜ä¼˜å…ˆçº§çš„ä¸‹ä¸€ä¸ªä»»åŠ¡ï¼ˆç²¾ç®€è¾“å‡ºï¼ŒèŠ‚çœ tokenï¼‰
    nxt = items[0]
    nf = nxt['fields']
    nid = nxt['record_id']
    nname = fv(nf, 'ä»»åŠ¡åç§°', 40)
    npri = fv(nf, 'ä¼˜å…ˆçº§')
    nphase = fv(nf, 'ä»»åŠ¡è¿›å±•')
    hint = f'  [{nphase}]' if nphase else ''
    total = len(items)
    more = f'ï¼ˆå…± {total} ä¸ªå¾…å¤„ç†ï¼‰' if total > 1 else ''
    print(f'  â­  ä¸‹ä¸€æ­¥ï¼š{fmt_priority(npri)} {c(C.WHITE, nname)}{c(C.GRAY, hint)}  {c(C.GRAY, more)}')
    print(f'  {c(C.GRAY, nid)}')

def _interrupt_check(c_, current_id=None):
    """ä¸­æ–­æ£€æŸ¥ï¼šæ˜¯å¦æœ‰æ›´é«˜ä¼˜å…ˆçº§ä»»åŠ¡éœ€è¦æ‰“æ–­å½“å‰ä»»åŠ¡ï¼ˆæ¯ä¸ªé˜¶æ®µ/å­ä»»åŠ¡å®Œæˆåè°ƒç”¨ï¼‰"""
    table_id = c_['tables']['tasks']['id']
    candidates = search_records(table_id, {
        'filter': {'conjunction': 'or', 'conditions': [
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸ”„ è¿›è¡Œä¸­']},
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸ• å¾…å¼€å§‹']},
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['â¸ï¸ å·²æš‚åœ']},
        ]},
        'field_names': ['ä»»åŠ¡åç§°', 'çŠ¶æ€', 'ä¼˜å…ˆçº§', 'æ‰§è¡Œåºå·'],
        'page_size': 20
    })
    if not candidates:
        return

    def sort_key(r):
        f = r.get('fields', {})
        return (_priority_rank(fv(f, 'ä¼˜å…ˆçº§')), _status_rank(fv(f, 'çŠ¶æ€')), int(fv(f, 'æ‰§è¡Œåºå·') or 999))

    ranked = sorted(candidates, key=sort_key)
    top = ranked[0]
    top_id   = top.get('record_id', '')
    tf       = top.get('fields', {})
    top_name = fv(tf, 'ä»»åŠ¡åç§°')
    top_pri  = fv(tf, 'ä¼˜å…ˆçº§')
    top_sta  = fv(tf, 'çŠ¶æ€')

    # æœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡å°±æ˜¯å½“å‰ä»»åŠ¡ â†’ æ— éœ€æ‰“æ–­
    if top_id == current_id:
        print(f'  {c(C.GRAY, "âœ” ä¸­æ–­æ£€æŸ¥ï¼šæ— æ›´é«˜ä¼˜å…ˆçº§ä»»åŠ¡ï¼Œç»§ç»­æ‰§è¡Œ")}')
        return

    # æœ€é«˜ä¼˜å…ˆçº§æ˜¯è¿›è¡Œä¸­ä¸”ä¸æ˜¯ current â†’ å¹¶å‘æƒ…å†µï¼ˆç†è®ºä¸Šä¸åº”å‡ºç°ï¼‰
    if top_sta == 'ğŸ”„ è¿›è¡Œä¸­':
        print(f'  {c(C.GRAY, "âœ” ä¸­æ–­æ£€æŸ¥ï¼šæ— æ›´é«˜ä¼˜å…ˆçº§ä»»åŠ¡")}')
        return

    # æœ‰æ›´é«˜ä¼˜å…ˆçº§çš„å¾…å¼€å§‹/å·²æš‚åœä»»åŠ¡
    print(f'\n  {c(C.YELLOW, "âš ï¸  ä¸­æ–­æç¤º")}ï¼šæœ‰æ›´é«˜ä¼˜å…ˆçº§ä»»åŠ¡ {fmt_priority(top_pri)} ã€Œ{top_name}ã€')
    print(f'  {c(C.GRAY, top_id)}')
    if current_id:
        hint = f'bm task interrupt {current_id} -m "æ–­ç‚¹æè¿°"  ç„¶åæ‰§è¡Œè¯¥ä»»åŠ¡'
        print(f'  â†’ {c(C.GRAY, hint)}')


def _count_logs_by_type(c_, task_id):
    """æŸ¥è¯¢æŸä»»åŠ¡çš„æ—¥å¿—ï¼ŒæŒ‰ç±»å‹ç»Ÿè®¡æ•°é‡ï¼Œè¿”å› dict"""
    log_table = c_['tables']['logs']['id']
    recs = search_records(log_table, {
        'filter': {'conjunction': 'and', 'conditions': [
            {'field_name': 'å…³è”ä»»åŠ¡ID', 'operator': 'is', 'value': [task_id]}
        ]},
        'field_names': ['ç±»å‹'],
        'page_size': 200
    })
    counts = {}
    for rec in recs:
        t = fv(rec.get('fields', {}), 'ç±»å‹')
        if t:
            counts[t] = counts.get(t, 0) + 1
    return counts


def task_token_snap(args):
    """bm task token-snap <task_id> <in_tokens>
    è®°å½•ä»»åŠ¡å¼€å§‹æ—¶çš„ token å¿«ç…§ï¼Œä¾› task done è®¡ç®—æ¶ˆè€— deltaã€‚
    ç”± agent åœ¨ bm task add åç«‹å³è°ƒç”¨ï¼ˆå…ˆæŸ¥ session_status è·å–å½“å‰ token æ•°ï¼‰ã€‚
    """
    state = _load_state()
    state[f'token_snap_{args.task_id}'] = {
        'in': int(float(args.in_tokens)),
        'at': int(time.time())
    }
    _save_state(state)
    print(f"ğŸ’¾ token å¿«ç…§å·²è®°å½•: {int(float(args.in_tokens)):,} in-tokens @ {args.task_id}")


def task_done(args):
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    now_ms = int(time.time() * 1000)
    done_fields = {'çŠ¶æ€': 'âœ… å·²å®Œæˆ', 'å®Œæˆæ—¶é—´': now_ms, 'ä»»åŠ¡è¿›å±•': 'âœ… äº¤ä»˜å®Œæˆ'}
    # è¯»å–å½“å‰è®°å½•
    rec = api('GET', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{args.id}')
    rec_fields = rec.get('data', {}).get('record', {}).get('fields', {})
    # â”€â”€ é˜²å‘†â‘ ï¼šä»»åŠ¡çŠ¶æ€æ£€æŸ¥ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    cur_status = fv(rec_fields, 'çŠ¶æ€')
    if cur_status == 'âœ… å·²å®Œæˆ':
        warn(f'ä»»åŠ¡å·²ç»æ˜¯å®ŒæˆçŠ¶æ€ï¼Œæ— éœ€é‡å¤æ“ä½œ')
        return
    if cur_status == 'ğŸ• å¾…å¼€å§‹':
        warn(f'ä»»åŠ¡ä»æœªå¼€å§‹æ‰§è¡Œï¼ˆå¾…å¼€å§‹çŠ¶æ€ï¼‰ï¼')
        print(f'   å…ˆè¿è¡Œï¼š{c(C.GRAY, f"bm task up {args.id} çŠ¶æ€ ğŸ”„è¿›è¡Œä¸­")}')
        print(f'   å¦‚ç¡®è®¤è¦ç›´æ¥å®Œæˆï¼ˆè·³è¿‡æ‰§è¡Œï¼‰ï¼Œè¯·åŠ  --force å‚æ•°')
        if not getattr(args, 'force', False):
            return
    # è‡ªåŠ¨è®¡ç®—æ—¶é•¿
    start_ts = rec_fields.get('å¼€å§‹æ‰§è¡Œæ—¶é—´')
    duration_sec = None
    if start_ts and isinstance(start_ts, (int, float)):
        duration_sec = round((now_ms - start_ts) / 1000, 0)
        # å®é™…è€—æ—¶å·²åˆ ï¼Œå…¬å¼å­—æ®µè‡ªåŠ¨è®¡ç®—ï¼Œä¸éœ€è¦æ‰‹åŠ¨å†™å…¥
    # â”€â”€ Token å¼€é”€ï¼šä¼˜å…ˆç”¨ --tokens-now è‡ªåŠ¨ç®— deltaï¼Œå…¶æ¬¡ç”¨ -t æ‰‹åŠ¨æŒ‡å®š â”€â”€
    token_cost = 0
    tokens_now = getattr(args, 'tokens_now', 0)
    if tokens_now:
        state = _load_state()
        snap = state.get(f'token_snap_{args.id}')
        if snap:
            token_cost = max(0, tokens_now - snap['in'])
            # æ¸…é™¤å¿«ç…§
            del state[f'token_snap_{args.id}']
            _save_state(state)
        else:
            token_cost = tokens_now  # æ²¡æœ‰å¿«ç…§å°±ç›´æ¥ç”¨å½“å‰å€¼
    elif args.tokens:
        token_cost = args.tokens
    if token_cost:
        done_fields['Token å¼€é”€'] = token_cost
    # ç»“æœæ‘˜è¦
    if args.summary:
        done_fields['ç»“æœæ‘˜è¦'] = args.summary
    r = api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{args.id}',
        {'fields': done_fields})
    if r.get('code') == 0:
        name = fv(rec_fields, 'ä»»åŠ¡åç§°')
        parts = [f'ä»»åŠ¡å®Œæˆ: {name}']
        if duration_sec is not None: parts.append(f'{int(duration_sec)}ç§’')
        if token_cost: parts.append(f'Token {token_cost:,}')
        ok('  '.join(parts))
        # â”€â”€ æ—¥å¿—è®¡æ•°ï¼ˆå­ä»»åŠ¡éœ€ä»çˆ¶ä»»åŠ¡æ—¥å¿—ä¸­æŒ‰å‰ç¼€è¿‡æ»¤ï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if not args.summary:
            warn(f'å»ºè®®å¡«å†™ç»“æœæ‘˜è¦: bm task done {args.id} -s "..."')
        # â”€â”€ æ²‰æ·€æç¤ºï¼ˆfinding + errorï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        log_table = c_['tables']['logs']['id']
        error_cnt = int(rec_fields.get('é”™è¯¯æ¬¡æ•°') or 0)
        if error_cnt > 0:
            print(f'{C.RED}âš   æœ‰ {error_cnt} æ¡é”™è¯¯è®°å½•{C.RESET}')
            print(f'   {c(C.GRAY, f"bm log ls {args.id} --type error")}  â† æŸ¥çœ‹é”™è¯¯è¯¦æƒ…')
        # â”€â”€ ManusåŸåˆ™â‘¤ï¼šå®Œæ•´æ€§æ£€æŸ¥ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        log_counts = _count_logs_by_type(c_, args.id)
        has_plan = log_counts.get('ğŸ“‹ è®¡åˆ’', 0) > 0
        has_milestone = log_counts.get('ğŸ é‡Œç¨‹ç¢‘', 0) > 0
        if not has_plan:
            warn(f'ä»»åŠ¡æ²¡æœ‰ plan æ—¥å¿—')
        if not has_milestone:
            warn(f'ä»»åŠ¡æ²¡æœ‰ milestone æ—¥å¿—ï¼ˆå»ºè®®è‡³å°‘è®°å½•ä¸€ä¸ªé‡Œç¨‹ç¢‘ï¼‰')
        # æ¸…ç†æ³¨æ„åŠ›è®¡æ•°å™¨
        _reset_log_count(args.id)
        # â”€â”€ è‡ªåŠ¨æ‰«ä¸‹ä¸€ä¸ªä»»åŠ¡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        _show_next_tasks(c_)
        # â”€â”€ è‡ªåŠ¨è°ƒåº¦ä¸‹ä¸€ä¸ªä»»åŠ¡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pass  # dispatch ç”±å¿ƒè·³é©±åŠ¨
    else:
        err(f'æ›´æ–°å¤±è´¥: {r.get("msg")}')

def task_update(args):
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    fields = {args.field: args.value}
    # çŠ¶æ€â†’è¿›è¡Œä¸­ æ—¶è‡ªåŠ¨è¡¥å¼€å§‹æ—¶é—´
    if args.field == 'çŠ¶æ€' and 'è¿›è¡Œä¸­' in args.value:
        rec = api('GET', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{args.id}')
        existing = rec.get('data', {}).get('record', {}).get('fields', {}).get('å¼€å§‹æ‰§è¡Œæ—¶é—´')
        if not existing:
            fields['å¼€å§‹æ‰§è¡Œæ—¶é—´'] = int(time.time() * 1000)
            info(f'å·²è‡ªåŠ¨å¡«å†™å¼€å§‹æ‰§è¡Œæ—¶é—´')
    r = api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{args.id}',
        {'fields': fields})
    if r.get('code') == 0:
        ok(f'[{args.field}] å·²æ›´æ–°')
        # æ˜¾ç¤ºæˆªæ–­å€¼
        val_preview = args.value[:80].replace('\n', 'â†µ')
        print(f'   {c(C.CYAN, val_preview)}')
    else:
        err(f'æ›´æ–°å¤±è´¥: {r.get("msg")}  {r}')

def notify_owner(task_id, task_name, error_count, last_error):
    """å‘ owner å‘é£ä¹¦æ¶ˆæ¯ï¼Œå‘ŠçŸ¥ä»»åŠ¡å› é”™è¯¯è¿‡å¤šå·²é˜»å¡"""
    msg = (
        f"ğŸš¨ ä»»åŠ¡å‡ºé”™è¿‡å¤šï¼Œéœ€è¦æ‚¨ä»‹å…¥ï¼\n\n"
        f"ğŸ“‹ ä»»åŠ¡ï¼š{task_name}ï¼ˆ{task_id}ï¼‰\n"
        f"âŒ å·²å¤±è´¥ï¼š{error_count} æ¬¡ï¼ˆä¸Šé™ {MAX_ERROR_RETRIES} æ¬¡ï¼‰\n"
        f"ğŸ“ æœ€è¿‘é”™è¯¯ï¼š{last_error[:200]}\n\n"
        f"ä»»åŠ¡å·²è‡ªåŠ¨æ ‡è®°ä¸ºã€é˜»å¡ä¸­ã€‘ï¼Œç­‰å¾…æ‚¨å¤„ç†ã€‚"
    )
    body = {
        'receive_id': OWNER_OPEN_ID,
        'msg_type': 'text',
        'content': json.dumps({'text': msg}, ensure_ascii=False)
    }
    r = api('POST', '/im/v1/messages?receive_id_type=open_id', body)
    if r.get('code') == 0:
        warn('å·²é€šçŸ¥ owner ä»‹å…¥å¤„ç†')
    else:
        warn(f'é€šçŸ¥å‘é€å¤±è´¥ï¼ˆä¸å½±å“ä»»åŠ¡çŠ¶æ€ï¼‰: {r.get("msg")}')

def task_block_internal(c_, task_id, reason):
    """å†…éƒ¨è°ƒç”¨ï¼šç›´æ¥ç”¨ id é˜»å¡ä»»åŠ¡"""
    table_id = c_['tables']['tasks']['id']
    r = api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{task_id}',
        {'fields': {'çŠ¶æ€': 'ğŸš§ é˜»å¡ä¸­'}})
    return r.get('code') == 0

def task_block(args):
    c_ = cfg()
    if task_block_internal(c_, args.id, args.reason):
        warn(f'ä»»åŠ¡ {args.id} å·²æ ‡è®°é˜»å¡')
        print(f'   åŸå› : {c(C.YELLOW, args.reason)}')
    else:
        err(f'æ›´æ–°å¤±è´¥')

def task_interrupt(args):
    """æ‰“æ–­å½“å‰ä»»åŠ¡ï¼Œä¿å­˜æ–­ç‚¹ï¼Œè®©å‡ºæ‰§è¡Œæƒç»™æ›´é«˜ä¼˜å…ˆçº§ä»»åŠ¡"""
    c_ = cfg()
    table_id  = c_['tables']['tasks']['id']
    log_table = c_['tables']['logs']['id']
    # è¯»å–å½“å‰ä»»åŠ¡ä¿¡æ¯
    rec = api('GET', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{args.id}')
    if rec.get('code') != 0:
        err(f'æ‰¾ä¸åˆ°ä»»åŠ¡: {args.id}')
    f = rec['data']['record']['fields']
    name = fv(f, 'ä»»åŠ¡åç§°')
    phase = fv(f, 'ä»»åŠ¡è¿›å±•') or 'æœªè®¾ç½®'
    note = args.note or 'æ‰‹åŠ¨æ‰“æ–­ï¼Œå¾…æ¢å¤'
    # å†™ checkpoint æ—¥å¿—
    checkpoint_content = f'[æ‰“æ–­æ–­ç‚¹]\nä»»åŠ¡è¿›å±•ï¼š{phase}\næ¢å¤æç¤ºï¼š{note}'
    api('POST', f'/bitable/v1/apps/{c_["app_token"]}/tables/{log_table}/records',
        {'fields': {
            'å†…å®¹': checkpoint_content,
            'å…³è”ä»»åŠ¡ID': args.id,
            'ç±»å‹': 'ğŸ’¾ æ–­ç‚¹å¿«ç…§',
            'é˜¶æ®µ': phase,
        }})
    # æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºå·²æš‚åœ
    api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{args.id}',
        {'fields': {
            'çŠ¶æ€': 'â¸ï¸ å·²æš‚åœ',
        }})
    print(f'\n{c(C.CYAN, "â¸ï¸  ä»»åŠ¡å·²æš‚åœ")}  {c(C.WHITE, name)}')
    print(f'   æ–­ç‚¹å·²ä¿å­˜ï¼š{c(C.GRAY, note[:80])}')
    print(f'   æ¢å¤æ—¶è¿è¡Œï¼š{c(C.GRAY, f"bm task up {args.id} çŠ¶æ€ ğŸ”„è¿›è¡Œä¸­")}')

def task_ls(args):
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    if args.all:
        statuses = ['ğŸ• å¾…å¼€å§‹', 'ğŸ”„ è¿›è¡Œä¸­', 'â¸ï¸ å·²æš‚åœ', 'ğŸš§ é˜»å¡ä¸­', 'âœ… å·²å®Œæˆ', 'âŒ å·²å–æ¶ˆ']
    elif args.status:
        status_map = {
            'å¾…å¼€å§‹':'ğŸ• å¾…å¼€å§‹','è¿›è¡Œä¸­':'ğŸ”„ è¿›è¡Œä¸­',
            'é˜»å¡':'ğŸš§ é˜»å¡ä¸­','é˜»å¡ä¸­':'ğŸš§ é˜»å¡ä¸­',
            'å®Œæˆ':'âœ… å·²å®Œæˆ','å·²å®Œæˆ':'âœ… å·²å®Œæˆ',
            'æš‚åœ':'â¸ï¸ å·²æš‚åœ','å·²æš‚åœ':'â¸ï¸ å·²æš‚åœ',
        }
        statuses = [status_map.get(s.strip(), s.strip()) for s in args.status.split(',')]
    else:
        statuses = ['ğŸ”„ è¿›è¡Œä¸­', 'â¸ï¸ å·²æš‚åœ', 'ğŸš§ é˜»å¡ä¸­']

    conditions = [{'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': [s]} for s in statuses]
    recs = search_records(table_id, {
        'filter': {'conjunction': 'or' if len(conditions)>1 else 'and', 'conditions': conditions},
        'sort': [{'field_name': 'ä¼˜å…ˆçº§', 'desc': False},
                 {'field_name': 'æ‰§è¡Œåºå·', 'desc': False}],
        'field_names': ['ä»»åŠ¡åç§°', 'çŠ¶æ€', 'ä¼˜å…ˆçº§', 'æ‰§è¡Œåºå·', 'ä»»åŠ¡è¿›å±•', 'ç»“æœæ‘˜è¦', 'é”™è¯¯æ¬¡æ•°']
    })
    label = 'ã€'.join(statuses)
    print(f'\n{c(C.BOLD, "ğŸ“‹ ä»»åŠ¡åˆ—è¡¨")}  {c(C.GRAY, label)}  ({len(recs)} ä¸ª)\n')
    if not recs:
        info('æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„ä»»åŠ¡')
        return
    for rec in recs:
        print_task_line(rec)
        print()

def task_resume(args):
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    log_table = c_['tables']['logs']['id']
    recs_raw = search_records(table_id, {
        'filter': {'conjunction': 'or', 'conditions': [
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸ”„ è¿›è¡Œä¸­']},
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['â¸ï¸ å·²æš‚åœ']},
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸš§ é˜»å¡ä¸­']},
        ]},
        'sort': [{'field_name': 'æ‰§è¡Œåºå·', 'desc': False}]
    })
    # æš‚åœä»»åŠ¡ä¼˜å…ˆï¼šâ¸ï¸ â†’ ğŸ”„ â†’ ğŸš§
    STATUS_ORDER = {'â¸ï¸ å·²æš‚åœ': 0, 'ğŸ”„ è¿›è¡Œä¸­': 1, 'ğŸš§ é˜»å¡ä¸­': 2}
    recs = sorted(recs_raw, key=lambda r: STATUS_ORDER.get(
        (r.get('fields') or {}).get('çŠ¶æ€', [''])[0] if isinstance((r.get('fields') or {}).get('çŠ¶æ€'), list)
        else (r.get('fields') or {}).get('çŠ¶æ€', ''), 99))
    if not recs:
        recs = search_records(table_id, {
            'filter': {'conjunction': 'and', 'conditions': [
                {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸ• å¾…å¼€å§‹']},
            ]},
            'sort': [{'field_name': 'æ‰§è¡Œåºå·', 'desc': False}]
        })
        if not recs:
            ok('æ²¡æœ‰å¾…å¤„ç†çš„ä»»åŠ¡ ğŸ‰')
            return
        info('æ²¡æœ‰è¿›è¡Œä¸­ä»»åŠ¡ï¼Œä»¥ä¸‹æ˜¯å¾…å¼€å§‹ï¼š')

    print(f'\n{c(C.BOLD+C.BLUE, "ğŸ”„ 5é—®é‡å¯æ£€æŸ¥")}  å…± {len(recs)} ä¸ªä»»åŠ¡\n')
    for rec in recs:
        f = rec.get('fields', {})
        rid = rec.get('record_id', '')
        hr()
        print(f"{c(C.BOLD+C.WHITE, fv(f,'ä»»åŠ¡åç§°'))}  {c(C.GRAY, rid)}")
        print(f"  {fmt_status(fv(f,'çŠ¶æ€'))}  {fmt_priority(fv(f,'ä¼˜å…ˆçº§'))}")
        print()
        # 5é—®
        phase    = fv(f, 'ä»»åŠ¡è¿›å±•') or 'æœªè®¾ç½®'
        goal     = fv(f, 'åŸå§‹æŒ‡ä»¤', truncate=120) or fv(f, 'ä»»åŠ¡åç§°')

        print(f"  {c(C.BOLD,'ğŸ“ æˆ‘åœ¨å“ªé‡Œï¼Ÿ')}  {c(C.CYAN, phase)}")

        print(f"  {c(C.BOLD,'ğŸ ç›®æ ‡æ˜¯ä»€ä¹ˆï¼Ÿ')} {c(C.WHITE, goal[:100])}")
        # æœ€è¿‘æ—¥å¿—æ¡ç›®ï¼ˆåŠ¨æ€åŠ è½½ï¼‰
        recent_logs = search_records(log_table, {
            'filter': {'conjunction': 'and', 'conditions': [
                {'field_name': 'å…³è”ä»»åŠ¡ID', 'operator': 'is', 'value': [rid]}
            ]},
            'sort': [{'field_name': 'è®°å½•æ—¶é—´', 'desc': True}],
            'field_names': ['å†…å®¹', 'ç±»å‹', 'é˜¶æ®µ', 'è®°å½•æ—¶é—´'],
            'page_size': 3
        })
        if recent_logs:
            print(f"  {c(C.BOLD,'âœ… æœ€è¿‘è¿›åº¦ï¼š')}")
            for lg in recent_logs:
                lf = lg.get('fields', {})
                ltype = fv(lf, 'ç±»å‹')
                lcontent = fv(lf, 'å†…å®¹', truncate=100)
                print(f"     {c(C.GRAY, ltype)}  {lcontent}")
        # â”€â”€ ManusåŸåˆ™ï¼šè‡ªåŠ¨å¬å›ç›¸å…³è®°å¿† â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        task_name = fv(f, 'ä»»åŠ¡åç§°') or ''
        instruction = fv(f, 'åŸå§‹æŒ‡ä»¤') or ''
        keywords = _extract_keywords(task_name + ' ' + instruction)
        if keywords:
            _auto_recall(c_, keywords, context='resume')
        print()
    hr()

def task_phase(args):
    """å¿«é€Ÿæ›´æ–°ä»»åŠ¡è¿›å±•"""
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    r = api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{args.id}',
        {'fields': {'ä»»åŠ¡è¿›å±•': args.phase}})
    if r.get('code') == 0:
        ok(f'é˜¶æ®µå·²æ›´æ–°: {args.phase}')
        _interrupt_check(c_, args.id)
    else:
        err(f'æ›´æ–°å¤±è´¥: {r.get("msg")}')

def task_search(args):
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    kw = args.keyword
    # æœåŠ¡ç«¯å¤šå­—æ®µ contains ç­›é€‰ï¼Œé¿å…å…¨è¡¨æ‹‰å–
    search_fields = ['ä»»åŠ¡åç§°', 'åŸå§‹æŒ‡ä»¤', 'ç»“æœæ‘˜è¦']
    conditions = [{'field_name': fn, 'operator': 'contains', 'value': [kw]} for fn in search_fields]
    found = search_records(table_id, {
        'filter': {'conjunction': 'or', 'conditions': conditions},
        'field_names': ['ä»»åŠ¡åç§°', 'çŠ¶æ€', 'ä¼˜å…ˆçº§', 'æ‰§è¡Œåºå·', 'ç»“æœæ‘˜è¦', 'é”™è¯¯æ¬¡æ•°'],
        'sort': [{'field_name': 'æ‰§è¡Œåºå·', 'desc': True}],
    })
    print(f'\n{c(C.BOLD, "ğŸ” æœç´¢ç»“æœ")}  [{kw}]  ({len(found)} ä¸ª)\n')
    for rec in found:
        print_task_line(rec)
        print()

def _priority_rank(p):
    """ä¼˜å…ˆçº§æ•°å€¼ï¼ˆè¶Šå°è¶Šé«˜ï¼‰"""
    return {'ğŸ”´ ç´§æ€¥': 0, 'ğŸŸ¡ é‡è¦': 1, 'ğŸŸ¢ æ™®é€š': 2}.get(p, 9)

def _status_rank(s):
    """çŠ¶æ€æ•°å€¼ï¼ˆè¿›è¡Œä¸­æœ€ä¼˜å…ˆï¼‰"""
    return {'ğŸ”„ è¿›è¡Œä¸­': 0, 'â¸ï¸ å·²æš‚åœ': 1, 'ğŸ• å¾…å¼€å§‹': 2, 'ğŸš§ é˜»å¡ä¸­': 9}.get(s, 9)

def task_next(args):
    """è°ƒåº¦å™¨ï¼šæ‰«ææ‰€æœ‰æœªå®Œæˆä»»åŠ¡ï¼Œæ¨èå½“å‰åº”è¯¥æ‰§è¡Œçš„ä»»åŠ¡"""
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    # æ‹‰å–æ‰€æœ‰æ´»è·ƒä»»åŠ¡ï¼ˆå¾…å¼€å§‹+è¿›è¡Œä¸­+å·²æš‚åœï¼‰
    candidates = search_records(table_id, {
        'filter': {'conjunction': 'or', 'conditions': [
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸ”„ è¿›è¡Œä¸­']},
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸ• å¾…å¼€å§‹']},
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['â¸ï¸ å·²æš‚åœ']},
        ]},
        'field_names': ['ä»»åŠ¡åç§°', 'çŠ¶æ€', 'ä¼˜å…ˆçº§', 'æ‰§è¡Œåºå·', 'ä»»åŠ¡è¿›å±•', 'é”™è¯¯æ¬¡æ•°'],
        'page_size': 50
    })
    if not candidates:
        ok('æ²¡æœ‰å¾…å¤„ç†ä»»åŠ¡ï¼Œå…¨éƒ¨å®Œæˆ ğŸ‰')
        return

    # æŒ‰ä¼˜å…ˆçº§ â†’ çŠ¶æ€ â†’ åºå· æ’åº
    def sort_key(r):
        f = r.get('fields', {})
        pri = fv(f, 'ä¼˜å…ˆçº§')
        sta = fv(f, 'çŠ¶æ€')
        seq = int(fv(f, 'æ‰§è¡Œåºå·') or 999)
        return (_priority_rank(pri), _status_rank(sta), seq)

    ranked = sorted(candidates, key=sort_key)
    top = ranked[0]
    tf = top.get('fields', {})
    top_id   = top.get('record_id', '')
    top_name = fv(tf, 'ä»»åŠ¡åç§°')
    top_pri  = fv(tf, 'ä¼˜å…ˆçº§')
    top_sta  = fv(tf, 'çŠ¶æ€')
    top_phase = fv(tf, 'ä»»åŠ¡è¿›å±•') or ''

    print(f'\n{c(C.BOLD, "ğŸ¯ è°ƒåº¦å»ºè®®")}\n')

    # åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ‡æ¢
    in_progress = [r for r in candidates if fv(r.get('fields',{}), 'çŠ¶æ€') == 'ğŸ”„ è¿›è¡Œä¸­']
    current = in_progress[0] if in_progress else None

    need_switch = False   # æ˜¯å¦éœ€è¦åˆ‡æ¢ï¼ˆç”¨äº --notify åˆ¤æ–­ï¼‰

    if top_sta == 'ğŸ”„ è¿›è¡Œä¸­':
        # æœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡å·²ç»åœ¨æ‰§è¡Œ
        print(f'  {c(C.GREEN, "âœ… å½“å‰ä»»åŠ¡ä¼˜å…ˆçº§æœ€é«˜ï¼Œç»§ç»­æ‰§è¡Œï¼š")}')
        phase_hint = f'  [{top_phase}]' if top_phase else ''
        print(f'  {fmt_priority(top_pri)}  {c(C.WHITE, top_name)}{c(C.GRAY, phase_hint)}')
        print(f'  {c(C.GRAY, top_id)}')
    else:
        need_switch = True
        # æœ‰æ›´é«˜ä¼˜å…ˆçº§çš„å¾…å¼€å§‹/æš‚åœä»»åŠ¡
        cur_name = fv(current.get('fields', {}), 'ä»»åŠ¡åç§°') if current else 'ï¼ˆæ— ï¼‰'
        cur_pri  = fv(current.get('fields', {}), 'ä¼˜å…ˆçº§') if current else ''
        print(f'  {c(C.YELLOW, "âš   å»ºè®®åˆ‡æ¢ä»»åŠ¡ï¼")}')
        if current:
            print(f'  å½“å‰: {fmt_priority(cur_pri)}  {c(C.GRAY, cur_name)}')
        print(f'  {c(C.GREEN, "â†’ åº”åš")}:  {fmt_priority(top_pri)}  {c(C.WHITE, top_name)}')
        print(f'  {c(C.GRAY, top_id)}')
        if top_sta == 'ğŸ• å¾…å¼€å§‹':
            print(f'\n  å¼€å§‹æ‰§è¡Œï¼š{c(C.GRAY, f"bm task up {top_id} çŠ¶æ€ ğŸ”„è¿›è¡Œä¸­")}')
        elif top_sta == 'â¸ï¸ å·²æš‚åœ':
            print(f'\n  æ¢å¤æ‰§è¡Œï¼š{c(C.GRAY, f"bm task up {top_id} çŠ¶æ€ ğŸ”„è¿›è¡Œä¸­")}')

    # â”€â”€ --notifyï¼šå‘é£ä¹¦é€šçŸ¥ï¼ˆä»…å½“éœ€è¦åˆ‡æ¢ä¸”æœ€é«˜ä¼˜å…ˆæ˜¯ç´§æ€¥æ—¶ï¼‰â”€â”€â”€â”€â”€
    notify = getattr(args, 'notify', False)
    if notify and need_switch and top_pri == 'ğŸ”´ ç´§æ€¥':
        cur_info = f'ï¼ˆå½“å‰æ‰§è¡Œï¼š{cur_name}ï¼‰' if current else 'ï¼ˆå½“å‰æ— è¿›è¡Œä¸­ä»»åŠ¡ï¼‰'
        msg = (
            f"ğŸš¨ è°ƒåº¦æé†’ï¼šæœ‰ç´§æ€¥ä»»åŠ¡ç­‰å¾…æ‰§è¡Œï¼\n\n"
            f"ğŸ“‹ ç´§æ€¥ä»»åŠ¡ï¼š{top_name}\n"
            f"ğŸ“Œ çŠ¶æ€ï¼š{top_sta}\n"
            f"ğŸ”‘ IDï¼š{top_id}\n"
            f"{cur_info}\n\n"
            f"è¯·ä¼˜å…ˆå¤„ç†æ­¤ä»»åŠ¡ã€‚"
        )
        r = api('POST', '/im/v1/messages?receive_id_type=open_id', {
            'receive_id': OWNER_OPEN_ID,
            'msg_type': 'text',
            'content': json.dumps({'text': msg}, ensure_ascii=False)
        })
        if r.get('code') == 0:
            warn('å·²å‘é€é£ä¹¦æé†’ç»™ owner')
        else:
            warn(f'é£ä¹¦é€šçŸ¥å‘é€å¤±è´¥: {r.get("msg")}')

    # æ˜¾ç¤ºå®Œæ•´ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ˆæœ€å¤š5ä¸ªï¼‰
    if len(ranked) > 1:
        print(f'\n  {c(C.GRAY, "â”€â”€ ä¼˜å…ˆçº§é˜Ÿåˆ— â”€â”€")}')
        for i, r in enumerate(ranked[:5]):
            f = r.get('fields', {})
            rid = r.get('record_id', '')
            sta = fv(f, 'çŠ¶æ€')
            pri = fv(f, 'ä¼˜å…ˆçº§')
            name = fv(f, 'ä»»åŠ¡åç§°', 25)
            phase = fv(f, 'ä»»åŠ¡è¿›å±•', 15) or ''
            marker = c(C.GREEN, 'â–¶') if sta == 'ğŸ”„ è¿›è¡Œä¸­' else c(C.GRAY, f'{i+1}.')
            phase_str = c(C.GRAY, f' [{phase}]') if phase else ''
            print(f'  {marker} {fmt_priority(pri)}  {c(C.WHITE, name)}{phase_str}')
        if len(ranked) > 5:
            print(f'  {c(C.GRAY, f"  ... è¿˜æœ‰ {len(ranked)-5} ä¸ªä»»åŠ¡")}')

def subtask_add_batch(args):
    """bm subtask add <parent_id> <åç§°1> [åç§°2] ...
    æ‰¹é‡æ·»åŠ å­ä»»åŠ¡åˆ°çˆ¶ä»»åŠ¡ï¼ˆ1æ¬¡GET + 1æ¬¡PUTï¼Œæ¯”é€ä¸ªæ·»åŠ èŠ‚çœ N*2-2 æ¬¡APIè°ƒç”¨ï¼‰
    """
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    parent_id = args.parent_id
    names = args.names

    pr = api('GET', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{parent_id}')
    if pr.get('code') != 0:
        err(f'çˆ¶ä»»åŠ¡ {parent_id} ä¸å­˜åœ¨')
    pf = pr['data']['record']['fields']
    if fv(pf, 'çŠ¶æ€') == 'âœ… å·²å®Œæˆ':
        warn('çˆ¶ä»»åŠ¡å·²å®Œæˆï¼')

    current_plan = fv(pf, 'ä»»åŠ¡è¿›å±•') or ''
    if 'å­ä»»åŠ¡ï¼š' in current_plan:
        # å·²æœ‰å­ä»»åŠ¡è¡Œï¼šç›´æ¥æ›¿æ¢ï¼ˆä¸è¿½åŠ ï¼‰ï¼Œé¿å… log add plan å’Œ subtask add åŒå†™å¯¼è‡´é‡å¤
        idx = current_plan.find('å­ä»»åŠ¡ï¼š')
        rest = current_plan[idx + len('å­ä»»åŠ¡ï¼š'):]
        eol = rest.find('\n')
        after = rest[eol:] if eol >= 0 else ''
        new_plan = current_plan[:idx] + 'å­ä»»åŠ¡ï¼š' + ' â†’ '.join(names) + after
    else:
        new_plan = (current_plan.rstrip() + '\nå­ä»»åŠ¡ï¼š' + ' â†’ '.join(names)).strip()

    phase = f'ğŸ“{names[0]}ï¼šå¾…å¼€å§‹'
    api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{parent_id}',
        {'fields': {'ä»»åŠ¡è¿›å±•': new_plan, 'ä»»åŠ¡è¿›å±•': phase}})

    ok(f'æ‰¹é‡æ·»åŠ  {len(names)} ä¸ªå­ä»»åŠ¡ â†’ {c(C.GRAY, parent_id)}')
    print(f'   {c(C.CYAN, "å­ä»»åŠ¡ï¼š")} {c(C.WHITE, " â†’ ".join(names))}')
    saved = len(names) * 2 - 2
    if saved > 0:
        print(f'   {c(C.GRAY, f"èŠ‚çœ {saved} æ¬¡APIè°ƒç”¨ï¼ˆvsé€ä¸ª bm task add --parentï¼‰")}')



def _parse_subtasks(plan_txt):
    """ä»ä»»åŠ¡è¿›å±•å­—æ®µè§£æå­ä»»åŠ¡åç§°åˆ—è¡¨"""
    # å¤„ç†å­—é¢é‡ \n å’ŒçœŸæ­£çš„æ¢è¡Œ
    lines = plan_txt.replace('\\n', '\n').split('\n')
    for line in lines:
        line = line.strip()
        if line.startswith('å­ä»»åŠ¡') and ('ï¼š' in line or ':' in line):
            # "å­ä»»åŠ¡ï¼šè°ƒç ” â†’ å¼€å‘ â†’ ä¸Šçº¿" or "å­ä»»åŠ¡ï¼šâœ…è°ƒç ” â†’ å¼€å‘ â†’ âœ…ä¸Šçº¿"
            parts = line.split('ï¼š', 1)[-1] if 'ï¼š' in line else line.split(':', 1)[-1]
            names = [n.strip().lstrip('âœ…').strip() for n in parts.split('â†’')]
            return [n for n in names if n]
    return []


def subtask_done(args):
    """bm subtask done <parent_id> <subtask_name> [-s æ‘˜è¦]"""
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    log_table_id = c_['tables']['logs']['id']
    parent_id = args.parent_id
    subtask_name = args.subtask_name
    summary = args.summary or f'{subtask_name} å®Œæˆ'

    # è¯»çˆ¶ä»»åŠ¡
    pr = api('GET', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{parent_id}')
    if pr.get('code') != 0:
        err(f'çˆ¶ä»»åŠ¡ {parent_id} ä¸å­˜åœ¨')
    pf = pr['data']['record']['fields']

    # ä»ã€Œä»»åŠ¡è¿›å±•ã€å­—æ®µè§£æå­ä»»åŠ¡åˆ—è¡¨
    plan_txt = fv(pf, 'ä»»åŠ¡è¿›å±•') or ''
    subtasks = _parse_subtasks(plan_txt)
    if not subtasks:
        err(f'çˆ¶ä»»åŠ¡æ²¡æœ‰å­ä»»åŠ¡ï¼ˆä»»åŠ¡è¿›å±•ä¸­æœªæ‰¾åˆ°"å­ä»»åŠ¡ï¼š"æ®µè½ï¼‰')

    if subtask_name not in subtasks:
        err(f'å­ä»»åŠ¡ã€Œ{subtask_name}ã€æœªæ‰¾åˆ°\nå½“å‰å­ä»»åŠ¡: {", ".join(subtasks)}')

    # æ ‡è®°å®Œæˆï¼šåªåœ¨ã€Œå­ä»»åŠ¡ï¼šã€è¡Œä¸­æ›´æ–°
    lines = plan_txt.replace('\\n', '\n').split('\n')
    new_lines = []
    for line in lines:
        if line.strip().startswith('å­ä»»åŠ¡') and ('ï¼š' in line or ':' in line):
            # åªåœ¨å­ä»»åŠ¡è¡Œä¸­æ›¿æ¢
            line = line.replace(f'âœ…{subtask_name}', f'âœ…{subtask_name}')  # å·²å®Œæˆçš„ä¸åŠ¨
            line = line.replace(subtask_name, f'âœ…{subtask_name}')
            line = line.replace('âœ…âœ…', 'âœ…')
        new_lines.append(line)
    new_plan = '\n'.join(new_lines)

    # ç»Ÿè®¡å®Œæˆæƒ…å†µ
    done_count = sum(1 for s in subtasks if f'âœ…{s}' in new_plan)
    total_count = len(subtasks)
    all_done = done_count == total_count

    # æ›´æ–°ä»»åŠ¡è¿›å±•
    if all_done:
        phase = 'âœ… å…¨éƒ¨å®Œæˆ'
    else:
        next_sub = next((s for s in subtasks if f'âœ…{s}' not in new_plan), None)
        phase = f'ğŸ“{next_sub}' if next_sub else 'âœ… å…¨éƒ¨å®Œæˆ'

    update_fields = {'ä»»åŠ¡è¿›å±•': new_plan, 'ä»»åŠ¡è¿›å±•': phase}

    # å†™ milestone æ—¥å¿—
    api('POST', f'/bitable/v1/apps/{c_["app_token"]}/tables/{log_table_id}/records',
        {'fields': {
            'å…³è”ä»»åŠ¡ID': parent_id,
            'ç±»å‹': 'ğŸ é‡Œç¨‹ç¢‘',
            'å†…å®¹': f'[{subtask_name}] âœ… å®Œæˆï¼š{summary}',
        }})

    if all_done:
        now_ms = int(time.time() * 1000)
        done_summary = f'å…¨éƒ¨ {total_count} ä¸ªå­ä»»åŠ¡å·²å®Œæˆ'
        update_fields.update({
            'çŠ¶æ€': 'âœ… å·²å®Œæˆ',
            'å®Œæˆæ—¶é—´': now_ms,
            'ç»“æœæ‘˜è¦': done_summary,
        })
        api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{parent_id}',
            {'fields': update_fields})
        api('POST', f'/bitable/v1/apps/{c_["app_token"]}/tables/{log_table_id}/records',
            {'fields': {
                'å…³è”ä»»åŠ¡ID': parent_id,
                'ç±»å‹': 'ğŸ é‡Œç¨‹ç¢‘',
                'å†…å®¹': f'âœ… çˆ¶ä»»åŠ¡è‡ªåŠ¨å®Œæˆï¼š{done_summary}',
            }})
        ok(f'å­ä»»åŠ¡å®Œæˆ: {subtask_name}  [{done_count}/{total_count}]')
        print(f"   {c(C.GRAY, 'çˆ¶ä»»åŠ¡è¿›åº¦ï¼š')} {c(C.CYAN, new_plan[new_plan.find('å­ä»»åŠ¡'):].split(chr(10))[0][:60])}")
        print(f"\n{c(C.GREEN, 'ğŸ‰ æ‰€æœ‰å­ä»»åŠ¡å·²å®Œæˆ â†’ çˆ¶ä»»åŠ¡å·²è‡ªåŠ¨æ ‡è®°å®Œæˆï¼')}")
        _show_next_tasks(c_)
        # â”€â”€ è‡ªåŠ¨è°ƒåº¦ä¸‹ä¸€ä¸ªä»»åŠ¡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pass  # dispatch ç”±å¿ƒè·³é©±åŠ¨
    else:
        api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{parent_id}',
            {'fields': update_fields})
        ok(f'å­ä»»åŠ¡å®Œæˆ: {subtask_name}  [{done_count}/{total_count}]')
        plan_line = new_plan[new_plan.find('å­ä»»åŠ¡'):].split('\n')[0] if 'å­ä»»åŠ¡' in new_plan else ''
        print(f"   {c(C.GRAY, 'çˆ¶ä»»åŠ¡è¿›åº¦ï¼š')} {c(C.CYAN, plan_line[:60])}")
        next_sub = next((s for s in subtasks if f'âœ…{s}' not in new_plan), None)
        if next_sub:
            print(f"   {c(C.CYAN, 'â†’ ä¸‹ä¸€æ­¥ï¼š')} {c(C.WHITE, next_sub)}")
        _interrupt_check(c_, parent_id)
        # â”€â”€ è‡ªåŠ¨è°ƒåº¦ä¸‹ä¸€ä¸ªä»»åŠ¡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pass  # dispatch ç”±å¿ƒè·³é©±åŠ¨


def subtask_phase(args):
    """bm subtask phase <parent_id> <subtask_name> <step>
    æ›´æ–°ã€Œä»»åŠ¡è¿›å±•ã€ä¸ºæŒ‡å®šå­ä»»åŠ¡çš„å½“å‰æ­¥éª¤ã€‚
    """
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    parent_id = args.parent_id
    subtask_name = args.subtask_name
    step = args.step

    # è¯»çˆ¶ä»»åŠ¡
    pr = api('GET', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{parent_id}')
    if pr.get('code') != 0:
        err(f'çˆ¶ä»»åŠ¡ {parent_id} ä¸å­˜åœ¨')
    pf = pr['data']['record']['fields']

    # éªŒè¯å­ä»»åŠ¡å­˜åœ¨
    plan_txt = fv(pf, 'ä»»åŠ¡è¿›å±•') or ''
    subtasks = _parse_subtasks(plan_txt)
    if subtask_name not in subtasks:
        err(f'å­ä»»åŠ¡ã€Œ{subtask_name}ã€æœªæ‰¾åˆ°\nå½“å‰å­ä»»åŠ¡: {", ".join(subtasks)}')

    # åªæ›´æ–°ä»»åŠ¡è¿›å±•
    phase = f'ğŸ“{subtask_name}ï¼š{step}'
    r = api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{parent_id}',
        {'fields': {'ä»»åŠ¡è¿›å±•': phase}})
    if r.get('code') == 0:
        ok(f'ä»»åŠ¡è¿›å±•å·²æ›´æ–°')
        print(f"   {c(C.CYAN, 'ğŸ“')} {c(C.WHITE, f'{subtask_name}ï¼š{step}')}")
    else:
        err(f'æ›´æ–°å¤±è´¥: {r.get("msg")}')



def task_show(args):
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    r = api('GET', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{args.id}')
    rec = r.get('data', {}).get('record')
    if not rec:
        err(f'æ‰¾ä¸åˆ°è®°å½•: {args.id}')
    print_task_detail(rec)

    hr()

# â”€â”€ LOG å­å‘½ä»¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LOG_TYPE_MAP = {
    'plan':      'ğŸ“‹ è®¡åˆ’',
    'finding':   'ğŸ” å‘ç°',
    'error':     'âŒ é”™è¯¯',
    'decision':  'âœ… å†³ç­–',
    'milestone': 'ğŸ é‡Œç¨‹ç¢‘',
    'progress':  'ğŸ“ è¿›åº¦',
    'tool':      'ğŸ”§ å·¥å…·ç»“æœ',
    'resource':  'ğŸ”— èµ„æº',       # URL/æ–‡ä»¶è·¯å¾„ï¼Œå‹ç¼©å¯æ¢å¤åŸåˆ™
    'checkpoint': 'ğŸ’¾ æ–­ç‚¹å¿«ç…§',  # é•¿æ–­ç‚¹ä¸Šä¸‹æ–‡ï¼ˆ>500å­—æ—¶ï¼Œä¸å†™ä»»åŠ¡è¡¨ï¼Œå†™è¿™é‡Œï¼‰
}

# â”€â”€ Manus åŸåˆ™ï¼šçŠ¶æ€æ–‡ä»¶ï¼ˆæ³¨æ„åŠ›åˆ·æ–°è®¡æ•°å™¨ï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
STATE_FILE = '/root/.openclaw/workspace/.bm_state.json'

def _load_state():
    try:
        with open(STATE_FILE) as f:
            return json.load(f)
    except:
        return {}

def _save_state(state):
    with open(STATE_FILE, 'w') as f:
        json.dump(state, f)

def _bump_log_count(task_id):
    """æ¯æ¬¡ log_add åé€’å¢è®¡æ•°å™¨ï¼Œè¿”å›å½“å‰è®¡æ•°"""
    state = _load_state()
    key = f'log_count_{task_id}'
    state[key] = state.get(key, 0) + 1
    _save_state(state)
    return state[key]

def _reset_log_count(task_id):
    state = _load_state()
    state.pop(f'log_count_{task_id}', None)
    _save_state(state)

def upload_file(file_path, app_token):
    """ä¸Šä¼ æ–‡ä»¶åˆ°é£ä¹¦ï¼Œè¿”å› file_token"""
    import os, mimetypes
    token = get_token()
    filename = os.path.basename(file_path)
    with open(file_path, 'rb') as f:
        file_data = f.read()
    file_size = len(file_data)
    mime = mimetypes.guess_type(filename)[0] or 'application/octet-stream'
    boundary = 'BtUploadBoundary'
    def part(name, value):
        return (f'--{boundary}\r\nContent-Disposition: form-data; name="{name}"\r\n\r\n{value}\r\n').encode()
    body = (
        part('file_name', filename) +
        part('parent_type', 'bitable_file') +
        part('parent_node', app_token) +
        part('size', str(file_size)) +
        f'--{boundary}\r\nContent-Disposition: form-data; name="file"; filename="{filename}"\r\nContent-Type: {mime}\r\n\r\n'.encode() +
        file_data +
        f'\r\n--{boundary}--\r\n'.encode()
    )
    req = urllib.request.Request(
        'https://open.feishu.cn/open-apis/drive/v1/medias/upload_all',
        data=body, method='POST',
        headers={'Authorization': f'Bearer {token}',
                 'Content-Type': f'multipart/form-data; boundary={boundary}'})
    try:
        r = json.loads(urllib.request.urlopen(req).read())
        if r.get('code') == 0:
            return r['data']['file_token']
        else:
            warn(f'æ–‡ä»¶ä¸Šä¼ å¤±è´¥: [{r.get("code")}] {r.get("msg")}')
            return None
    except Exception as e:
        warn(f'æ–‡ä»¶ä¸Šä¼ å¼‚å¸¸: {e}')
        return None

def log_add(args):
    c_ = cfg()
    log_table  = c_['tables']['logs']['id']
    task_table = c_['tables']['tasks']['id']
    ltype = LOG_TYPE_MAP.get(args.type, args.type)

    # â”€â”€ è¯»å–ä»»åŠ¡è®°å½•ï¼ˆç”¨äºçŠ¶æ€æ£€æŸ¥ + é”™è¯¯è®¡æ•°ï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    task_rec = api('GET', f'/bitable/v1/apps/{c_["app_token"]}/tables/{task_table}/records/{args.task_id}')
    task_fields = task_rec['data']['record']['fields'] if task_rec.get('code') == 0 else {}

    # â”€â”€ ManusåŸåˆ™â‘£ï¼šplan å¿…é¡»å…ˆå†™æ£€æŸ¥ï¼ˆæœ¬åœ°ç¼“å­˜ï¼Œçœä¸€æ¬¡ APIï¼‰â”€â”€
    PLAN_TYPE = LOG_TYPE_MAP.get('plan', 'ğŸ“‹ è®¡åˆ’')
    if ltype != PLAN_TYPE and args.type != 'plan':
        state = _load_state()
        plan_key = f'has_plan_{args.task_id}'
        if not state.get(plan_key):
            # æ£€æŸ¥ä»»åŠ¡è¡¨ã€Œä»»åŠ¡è¿›å±•ã€å­—æ®µæ˜¯å¦æœ‰å†…å®¹ï¼ˆå·²åœ¨ task_fields é‡Œï¼Œä¸éœ€è¦é¢å¤– APIï¼‰
            has_plan = bool(fv(task_fields, 'ä»»åŠ¡è¿›å±•'))
            if has_plan:
                state[plan_key] = True
                _save_state(state)
            else:
                warn(f'è¿˜æ²¡å†™ plan æ—¥å¿—ï¼å»ºè®®å…ˆå†™ï¼šbm log add {args.task_id} plan "ç›®æ ‡ï¼š...\\né˜¶æ®µï¼š..."')

    # â”€â”€ ManusåŸåˆ™â‘ ï¼šå†…å®¹é•¿åº¦çº¦æŸï¼ˆè‡ªåŠ¨æˆªæ–­+è­¦å‘Šï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    content_text = args.content
    if len(content_text) > 500:
        warn(f'å†…å®¹è¶…è¿‡ 500 å­—ï¼ˆ{len(content_text)} å­—ï¼‰ï¼Œå·²è‡ªåŠ¨æˆªæ–­ã€‚è¶…å‡ºéƒ¨åˆ†è¯·ç”¨ --file é™„ä»¶')
        content_text = content_text[:500]

    # â”€â”€ é˜²å‘†â‘¢ï¼šå¯¹å·²å®Œæˆ/å·²å–æ¶ˆä»»åŠ¡å†™ error æ—¥å¿— â†’ æ‹’ç» â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if args.type == 'error':
        task_status = fv(task_fields, 'çŠ¶æ€')
        if task_status in ('âœ… å·²å®Œæˆ', 'âŒ å·²å–æ¶ˆ'):
            err(f'ä»»åŠ¡å·²{task_status}ï¼Œä¸èƒ½å†å†™å…¥é”™è¯¯æ—¥å¿—ã€‚å¦‚éœ€è®°å½•è¯·å…ˆé‡å¼€ä»»åŠ¡ã€‚')

    # â”€â”€ é”™è¯¯è®¡æ•° + é—¨ç¦ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    attempt_num = args.attempt or 0
    is_error = (args.type == 'error')
    new_error_count = None

    if is_error:
        cur = int(task_fields.get('é”™è¯¯æ¬¡æ•°') or 0) if task_fields else 0
        if cur >= 2:
            print(f'{C.YELLOW}âš   ç¬¬ {cur+1} æ¬¡é”™è¯¯ï¼æ ¸å¿ƒé“å¾‹ï¼šæ°¸è¿œä¸è¦é‡å¤å¤±è´¥çš„åŠ¨ä½œã€‚{C.RESET}')
            print(f'   {c(C.GRAY, "è¯·ç¡®è®¤å·²æ”¹å˜æ–¹æ³•å†ç»§ç»­ï¼ˆæŸ¥çœ‹å‰æ¬¡é”™è¯¯ï¼šbm log ls " + args.task_id + " --type errorï¼‰")}')
        new_error_count = cur + 1
        api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{task_table}/records/{args.task_id}',
            {'fields': {'é”™è¯¯æ¬¡æ•°': new_error_count}})
        attempt_num = new_error_count
        if not task_fields:
            warn(f'è¯»å–ä»»åŠ¡è®°å½•å¤±è´¥ï¼Œé”™è¯¯æ¬¡æ•°ä¸è‡ªåŠ¨æ›´æ–°')

    # â”€â”€ å†™å…¥ Base æ‰§è¡Œæ—¥å¿—è¡¨ï¼ˆplan ç±»å‹åŒæ—¶å†™ä»»åŠ¡è¡¨ã€Œä»»åŠ¡è¿›å±•ã€ï¼‰â”€â”€
    PLAN_TYPE = LOG_TYPE_MAP.get('plan', 'ğŸ“‹ è®¡åˆ’')
    if ltype == PLAN_TYPE:
        plan_content = content_text[:300]
        api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{task_table}/records/{args.task_id}',
            {'fields': {'ä»»åŠ¡è¿›å±•': plan_content}})
        print(f"   {c(C.BLUE, 'ğŸ“‹ è§„åˆ’ â†’')} ä»»åŠ¡è¡¨ã€Œä»»åŠ¡è¿›å±•ã€å­—æ®µ")
        # ç¼“å­˜ï¼šæ ‡è®°è¯¥ä»»åŠ¡å·²æœ‰ plan
        state = _load_state()
        state[f'has_plan_{args.task_id}'] = True
        _save_state(state)
    fields = {
        'å†…å®¹': content_text,
        'å…³è”ä»»åŠ¡ID': args.task_id,
        'ç±»å‹': ltype,
    }
    if args.phase: fields['é˜¶æ®µ'] = args.phase
    if attempt_num: pass  # é”™è¯¯æ¬¡æ•°å·²åœ¨ä»»åŠ¡è¡¨ç»Ÿè®¡

    if args.file:
        if not os.path.exists(args.file):
            err(f'æ–‡ä»¶ä¸å­˜åœ¨: {args.file}')
        info(f'ä¸Šä¼ æ–‡ä»¶: {os.path.basename(args.file)} ...')
        file_token = upload_file(args.file, c_['app_token'])
        if file_token:
            fields['é™„ä»¶'] = [{'file_token': file_token}]
            ok(f'æ–‡ä»¶å·²ä¸Šä¼ : {file_token[:20]}...')

    r = api('POST', f'/bitable/v1/apps/{c_["app_token"]}/tables/{log_table}/records',
        {'fields': fields})
    if r.get('code') == 0:
        rid = r['data']['record']['record_id']
        # â”€â”€ ManusåŸåˆ™â‘¢ï¼šä¸Šä¸‹æ–‡å¸è½½æç¤ºï¼ˆç²¾ç®€ä¸º1è¡Œï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ltype_short = ltype.split()[-1] if ' ' in ltype else ltype
        print(f"âœ… {ltype_short} â†’ {c(C.GRAY, rid)}")

        if args.phase:
            api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{task_table}/records/{args.task_id}',
                {'fields': {'ä»»åŠ¡è¿›å±•': args.phase}})
            print(f"   {c(C.CYAN, 'ğŸ“ ä»»åŠ¡è¿›å±• â†’')} {c(C.WHITE, args.phase)}")

        if is_error and new_error_count is not None:
            remaining = MAX_ERROR_RETRIES - new_error_count
            if remaining > 0:
                print(f"   âš   ç¬¬ {new_error_count}/{MAX_ERROR_RETRIES} æ¬¡é”™è¯¯  ï¼ˆè¿˜å‰© {remaining} æ¬¡æœºä¼šï¼‰")
            else:
                print(f"   {c(C.RED, f'ğŸš¨ å·²è¾¾æœ€å¤§é”™è¯¯æ¬¡æ•° ({MAX_ERROR_RETRIES})ï¼è‡ªåŠ¨é˜»å¡ä»»åŠ¡å¹¶é€šçŸ¥ owner...')}")
                task_block_internal(c_, args.task_id, f'é”™è¯¯æ¬¡æ•°å·²è¾¾ä¸Šé™({MAX_ERROR_RETRIES})ï¼Œéœ€ä¸»äººä»‹å…¥')
                rec2 = api('GET', f'/bitable/v1/apps/{c_["app_token"]}/tables/{task_table}/records/{args.task_id}')
                task_name = ''
                if rec2.get('code') == 0:
                    task_name = rec2['data']['record']['fields'].get('ä»»åŠ¡åç§°', args.task_id) or args.task_id
                notify_owner(args.task_id, task_name, new_error_count, args.content)

        # â”€â”€ ManusåŸåˆ™â‘¡ï¼šæ³¨æ„åŠ›åˆ·æ–°æé†’ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        log_count = _bump_log_count(args.task_id)
        if log_count > 0 and log_count % 10 == 0:
            print(f"   {c(C.CYAN, f'ğŸ”„ å·²å†™ {log_count} æ¡æ—¥å¿—ï¼Œå»ºè®®åˆ·æ–°æ³¨æ„åŠ›ï¼šbm task show {args.task_id}')}")
    else:
        err(f'å†™å…¥å¤±è´¥: {r.get("msg")}')


def log_ls(args):
    c_ = cfg()
    log_table = c_['tables']['logs']['id']
    conditions = [{'field_name': 'å…³è”ä»»åŠ¡ID', 'operator': 'is', 'value': [args.task_id]}]
    if args.type:
        ltype = LOG_TYPE_MAP.get(args.type, args.type)
        conditions.append({'field_name': 'ç±»å‹', 'operator': 'is', 'value': [ltype]})
    limit = args.last or 20
    recs = search_records(log_table, {
        'filter': {'conjunction': 'and', 'conditions': conditions},
        'sort': [{'field_name': 'è®°å½•æ—¶é—´', 'desc': True}],
        'field_names': ['å†…å®¹', 'ç±»å‹', 'é˜¶æ®µ', 'è®°å½•æ—¶é—´'],
        'page_size': 200
    })
    recs = recs[:limit]
    total = len(recs)
    label = f'  ç±»å‹:{args.type}' if args.type else ''
    print(f'\n{c(C.BOLD, "ğŸ“‹ æ‰§è¡Œæ—¥å¿—")}  [{args.task_id[:12]}]{label}  ({total} æ¡)\n')
    type_colors = {
        'âŒ é”™è¯¯': C.RED, 'ğŸ” å‘ç°': C.CYAN, 'âœ… å†³ç­–': C.GREEN,
        'ğŸ“‹ è®¡åˆ’': C.BLUE, 'ğŸ é‡Œç¨‹ç¢‘': C.YELLOW,
        'ğŸ“ è¿›åº¦': C.WHITE, 'ğŸ”§ å·¥å…·ç»“æœ': C.GRAY,
    }
    for rec in reversed(recs):
        f = rec.get('fields', {})
        ltype  = fv(f, 'ç±»å‹')
        phase  = fv(f, 'é˜¶æ®µ')
        ts     = fv(f, 'è®°å½•æ—¶é—´')
        content = fv(f, 'å†…å®¹', truncate=200)
        tc = type_colors.get(ltype, C.WHITE)
        header = c(tc, ltype)
        if phase: header += f'  {c(C.GRAY, phase)}'
        if ts:    header += f'  {c(C.GRAY, ts)}'
        print(f'  {header}')
        for line in content.split('\n')[:6]:
            print(f'    {c(tc, line)}')
        print()

# â”€â”€ MEM å­å‘½ä»¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

MEM_TYPE_MAP = {'çŸ¥è¯†': 'ğŸ“˜ çŸ¥è¯†', 'æ•™è®­': 'âš ï¸ æ•™è®­', 'åå¥½': 'ğŸ’¡ åå¥½', 'ä¸Šä¸‹æ–‡': 'ğŸ”— ä¸Šä¸‹æ–‡'}

def mem_add(args):
    c_ = cfg()
    mem_table = c_['tables']['memory']['id']
    mtype = MEM_TYPE_MAP.get(args.type, args.type)
    importance = {'æ ¸å¿ƒ': 'ğŸ”´ æ ¸å¿ƒ', 'é‡è¦': 'ğŸŸ¡ é‡è¦', 'æ™®é€š': 'ğŸŸ¢ æ™®é€š'}.get(args.importance, args.importance)
    content_text = args.content
    if len(content_text) > 800:
        warn(f'å†…å®¹è¶…è¿‡ 800 å­—ï¼ˆ{len(content_text)} å­—ï¼‰ï¼Œå·²æˆªæ–­')
        content_text = content_text[:800]
    fields = {
        'æ ‡é¢˜': args.title,
        'ç±»å‹': mtype,
        'é‡è¦åº¦': importance,
        'å†…å®¹': content_text,
        'æ˜¯å¦æ¿€æ´»': True,
        'è®°å½•æ—¶é—´': int(time.time() * 1000),
    }
    if args.task: fields['æ¥æºä»»åŠ¡ID'] = args.task
    r = api('POST', f'/bitable/v1/apps/{c_["app_token"]}/tables/{mem_table}/records', {'fields': fields})
    if r.get('code') == 0:
        rid = r['data']['record']['record_id']
        ok(f'è®°å¿†å·²å†™å…¥  {rid}')
        print(f"   {c(C.CYAN, mtype)}  {c(C.WHITE, args.title)}")
    else:
        err(f'å†™å…¥å¤±è´¥: {r.get("msg")}')


def mem_ls(args):
    c_ = cfg()
    mem_table = c_['tables']['memory']['id']
    recs = search_records(mem_table, {
        'filter': {'conjunction': 'and', 'conditions': [
            {'field_name': 'æ˜¯å¦æ¿€æ´»', 'operator': 'is', 'value': [True]}
        ]},
        'field_names': ['æ ‡é¢˜', 'ç±»å‹', 'é‡è¦åº¦', 'å†…å®¹', 'æ¥æºä»»åŠ¡ID'],
        'page_size': 50
    })
    print(f'\n{c(C.BOLD, "ğŸ“š è®°å¿†åº“")}  ({len(recs)} æ¡æ¿€æ´»)\n')
    for rec in recs:
        f = rec.get('fields', {})
        title = fv(f, 'æ ‡é¢˜')
        mtype = fv(f, 'ç±»å‹')
        imp = fv(f, 'é‡è¦åº¦')
        content = fv(f, 'å†…å®¹', truncate=80)
        print(f'  {imp or ""}  {mtype or ""}  {c(C.WHITE, title or "")}')
        if content: print(f'    {c(C.GRAY, content)}')


def mem_search(args):
    c_ = cfg()
    mem_table = c_['tables']['memory']['id']
    recs = search_records(mem_table, {
        'filter': {'conjunction': 'and', 'conditions': [
            {'field_name': 'æ˜¯å¦æ¿€æ´»', 'operator': 'is', 'value': [True]}
        ]},
        'field_names': ['æ ‡é¢˜', 'ç±»å‹', 'å†…å®¹', 'æ¥æºä»»åŠ¡ID'],
        'page_size': 200
    })
    kw = args.keyword.lower()
    hits = [r for r in recs if kw in (fv(r.get('fields',{}), 'æ ‡é¢˜') or '').lower()
            or kw in (fv(r.get('fields',{}), 'å†…å®¹') or '').lower()]
    print(f'\n{c(C.BOLD, "ğŸ” æœç´¢ç»“æœ")}  "{args.keyword}"  ({len(hits)} æ¡)\n')
    for rec in hits:
        f = rec.get('fields', {})
        title = fv(f, 'æ ‡é¢˜')
        content = fv(f, 'å†…å®¹', truncate=120)
        print(f'  {c(C.WHITE, title or "")}')
        if content: print(f'    {c(C.GRAY, content)}')
        print()


def log_search(args):
    """è·¨ä»»åŠ¡æœç´¢æ‰§è¡Œæ—¥å¿—ï¼ˆæœåŠ¡ç«¯ contains æœç´¢ï¼‰"""
    c_ = cfg()
    log_table = c_['tables']['logs']['id']
    task_table = c_['tables']['tasks']['id']

    # æœåŠ¡ç«¯æœç´¢ï¼šå†…å®¹å­—æ®µ contains å…³é”®è¯
    recs = search_records(log_table, {
        'filter': {'conjunction': 'and', 'conditions': [
            {'field_name': 'å†…å®¹', 'operator': 'contains', 'value': [args.keyword]}
        ]},
        'sort': [{'field_name': 'è®°å½•æ—¶é—´', 'desc': True}],
        'field_names': ['å†…å®¹', 'å…³è”ä»»åŠ¡ID', 'ç±»å‹', 'é˜¶æ®µ', 'è®°å½•æ—¶é—´'],
        'page_size': 200
    })

    limit = args.last or 15
    recs = recs[:limit]

    # æ‰¹é‡è·å–å…³è”ä»»åŠ¡åç§°ï¼ˆå»é‡ï¼‰
    task_ids = set()
    for rec in recs:
        tid = fv(rec.get('fields', {}), 'å…³è”ä»»åŠ¡ID')
        if tid: task_ids.add(tid)

    task_names = {}
    for tid in task_ids:
        r = api('GET', f'/bitable/v1/apps/{c_["app_token"]}/tables/{task_table}/records/{tid}')
        if r.get('code') == 0:
            task_names[tid] = fv(r['data']['record']['fields'], 'ä»»åŠ¡åç§°') or tid[:12]

    print(f'\n{c(C.BOLD, "ğŸ” æ—¥å¿—æœç´¢")}  "{args.keyword}"  ({len(recs)} æ¡)\n')

    type_colors = {
        'âŒ é”™è¯¯': C.RED, 'ğŸ” å‘ç°': C.CYAN, 'âœ… å†³ç­–': C.GREEN,
        'ğŸ“‹ è®¡åˆ’': C.BLUE, 'ğŸ é‡Œç¨‹ç¢‘': C.YELLOW,
        'ğŸ“ è¿›åº¦': C.WHITE, 'ğŸ”§ å·¥å…·ç»“æœ': C.GRAY,
    }

    for rec in recs:
        f = rec.get('fields', {})
        ltype   = fv(f, 'ç±»å‹')
        tid     = fv(f, 'å…³è”ä»»åŠ¡ID')
        ts      = fv(f, 'è®°å½•æ—¶é—´')
        content = fv(f, 'å†…å®¹', truncate=150)
        tname   = task_names.get(tid, tid[:12] if tid else '?')

        tc = type_colors.get(ltype, C.WHITE)
        header = f'{c(tc, ltype)}  {c(C.WHITE, tname)}'
        if ts: header += f'  {c(C.GRAY, ts)}'
        print(f'  {header}')
        for line in content.split('\n')[:4]:
            print(f'    {c(C.GRAY, line)}')
        print()


# â”€â”€ DISPATCH å­å‘½ä»¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _build_dispatch_prompt(task_rec, subtask_name, c_):
    """ä» Base ä»»åŠ¡è®°å½•æ„å»º sub-agent prompt"""
    f = task_rec.get('fields', {})
    record_id = task_rec.get('record_id', '')
    name = fv(f, 'ä»»åŠ¡åç§°')
    instruction = fv(f, 'åŸå§‹æŒ‡ä»¤')
    plan = fv(f, 'ä»»åŠ¡è¿›å±•')
    phase = fv(f, 'ä»»åŠ¡è¿›å±•')

    # è§£æå­ä»»åŠ¡è¿›åº¦
    subtasks = _parse_subtasks(plan) if plan else []
    progress_lines = ''
    if subtasks:
        lines = []
        for s in subtasks:
            if plan and f'âœ…{s}' in plan:
                lines.append(f'âœ… {s}')
            elif subtask_name and s == subtask_name:
                lines.append(f'ğŸ“ {s} â† å½“å‰')
            else:
                lines.append(f'â—‹ {s}')
        progress_lines = '\n'.join(lines)

    # è¯»æœ€è¿‘æ—¥å¿—
    log_table_id = c_['tables']['logs']['id']
    log_lines = ''
    if log_table_id and record_id:
        try:
            log_recs = search_records(log_table_id, {
                'filter': {'conjunction': 'and', 'conditions': [
                    {'field_name': 'å…³è”ä»»åŠ¡ID', 'operator': 'is', 'value': [record_id]},
                ]},
                'field_names': ['ç±»å‹', 'å†…å®¹', 'é˜¶æ®µ', 'è®°å½•æ—¶é—´'],
                'sort': [{'field_name': 'è®°å½•æ—¶é—´', 'desc': True}],
                'page_size': 10,
            })
            if log_recs:
                logs = []
                for lr in log_recs:
                    lf = lr.get('fields', {})
                    t = fv(lf, 'ç±»å‹')
                    ct = fv(lf, 'å†…å®¹')
                    if ct:
                        logs.append(f'- [{t}] {ct}')
                log_lines = '\n'.join(logs)
        except:
            pass

    # æ‹¼è£… prompt
    parts = []
    parts.append(f'## ä»»åŠ¡ç›®æ ‡\n{name}')
    if instruction:
        parts.append(f'## åŸå§‹æŒ‡ä»¤\n{instruction}')
    if plan:
        parts.append(f'## æ•´ä½“è§„åˆ’\n{plan}')
    if progress_lines:
        parts.append(f'## å½“å‰è¿›åº¦\n{progress_lines}')
    elif phase:
        parts.append(f'## å½“å‰è¿›åº¦\n{phase}')
    if subtask_name:
        parts.append(f'## å½“å‰å­ä»»åŠ¡\nåç§°ï¼š{subtask_name}')
    if log_lines:
        parts.append(f'## å…³é”®å‘ç°å’Œå†³ç­–ï¼ˆä»æ—¥å¿—è¡¨ï¼‰\n{log_lines}')

    # æŒ‡ä»¤ï¼šsub-agent ç”¨ bt å‘½ä»¤æ›´æ–° Base
    bt_instructions = [
        '## æ‰§è¡Œè¦æ±‚',
        f'ä»»åŠ¡IDï¼š{record_id}',
        '',
        'ä½ æœ‰å®Œæ•´çš„å·¥å…·æƒé™ï¼ˆshellã€æ–‡ä»¶è¯»å†™ã€ç½‘ç»œæœç´¢ç­‰ï¼‰ã€‚',
        'è¯·æ‰§è¡Œä¸Šè¿°ä»»åŠ¡ï¼Œå¹¶ç”¨ä»¥ä¸‹ bt å‘½ä»¤æ›´æ–°è¿›åº¦ï¼š',
        '',
        f'- è®°å½•å‘ç°ï¼š`bt log add {record_id} finding "å‘ç°å†…å®¹"`',
        f'- è®°å½•å†³ç­–ï¼š`bt log add {record_id} decision "å†³ç­–å†…å®¹"`',
        f'- è®°å½•é”™è¯¯ï¼š`bt log add {record_id} error "é”™è¯¯å†…å®¹"`',
        f'- æ›´æ–°é˜¶æ®µï¼š`bt task phase {record_id} "é˜¶æ®µN-æè¿°"`',
    ]
    if subtask_name:
        bt_instructions.append(f'- å­ä»»åŠ¡å®Œæˆï¼š`bt subtask done {record_id} "{subtask_name}" -s "æ‘˜è¦"`')
    else:
        bt_instructions.append(f'- ä»»åŠ¡å®Œæˆï¼š`bt task done {record_id} -s "ç»“æœæ‘˜è¦"`')
    bt_instructions.extend([
        '',
        'å®ŒæˆååŠ¡å¿…è°ƒç”¨ä¸Šé¢çš„ done å‘½ä»¤æ ‡è®°å®Œæˆã€‚',
    ])
    parts.append('\n'.join(bt_instructions))

    return '\n\n'.join(parts)


def _find_first_incomplete_subtask(plan_txt):
    """æ‰¾åˆ°ç¬¬ä¸€ä¸ªæœªå®Œæˆçš„å­ä»»åŠ¡"""
    if not plan_txt:
        return None
    subtasks = _parse_subtasks(plan_txt)
    if not subtasks:
        return None
    for name in subtasks:
        if f'âœ…{name}' not in plan_txt:
            return name
    return None  # å…¨éƒ¨å®Œæˆ


def dispatch_prep(args):
    """bt dispatch prep â€” å‡†å¤‡ä¸‹ä¸€ä¸ªå¾…æ‰§è¡Œä»»åŠ¡çš„ promptï¼Œè¾“å‡º JSON"""
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']

    # å¤ç”¨ task_next çš„æ’åºé€»è¾‘
    candidates = search_records(table_id, {
        'filter': {'conjunction': 'or', 'conditions': [
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸ”„ è¿›è¡Œä¸­']},
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸ• å¾…å¼€å§‹']},
        ]},
        'field_names': ['ä»»åŠ¡åç§°', 'çŠ¶æ€', 'ä¼˜å…ˆçº§', 'æ‰§è¡Œåºå·', 'ä»»åŠ¡è¿›å±•', 'é”™è¯¯æ¬¡æ•°', 'ä»»åŠ¡è¿›å±•', 'åŸå§‹æŒ‡ä»¤'],
        'page_size': 50
    })
    if not candidates:
        print(json.dumps({'status': 'empty', 'message': 'æ²¡æœ‰å¾…å¤„ç†ä»»åŠ¡'}, ensure_ascii=False))
        return

    def sort_key(r):
        f = r.get('fields', {})
        pri = fv(f, 'ä¼˜å…ˆçº§')
        sta = fv(f, 'çŠ¶æ€')
        seq = int(fv(f, 'æ‰§è¡Œåºå·') or 999)
        return (_priority_rank(pri), _status_rank(sta), seq)

    ranked = sorted(candidates, key=sort_key)
    task = ranked[0]
    f = task.get('fields', {})
    record_id = task.get('record_id', '')
    name = fv(f, 'ä»»åŠ¡åç§°')
    priority = fv(f, 'ä¼˜å…ˆçº§')
    plan_txt = fv(f, 'ä»»åŠ¡è¿›å±•')
    error_count = int(float(fv(f, 'é”™è¯¯æ¬¡æ•°') or '0'))

    # æ£€æŸ¥é”™è¯¯æ¬¡æ•°
    if error_count >= MAX_ERROR_RETRIES:
        print(json.dumps({
            'status': 'blocked',
            'recordId': record_id,
            'message': f'é”™è¯¯æ¬¡æ•°å·²è¾¾ä¸Šé™({error_count}/{MAX_ERROR_RETRIES})'
        }, ensure_ascii=False))
        return

    # æ‰¾å­ä»»åŠ¡
    subtask_name = _find_first_incomplete_subtask(plan_txt)

    # å¦‚æœæ˜¯å¾…å¼€å§‹ï¼Œæ›´æ–°ä¸ºè¿›è¡Œä¸­
    status = fv(f, 'çŠ¶æ€')
    if status == 'ğŸ• å¾…å¼€å§‹':
        api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{record_id}', {
            'fields': {
                'çŠ¶æ€': 'ğŸ”„ è¿›è¡Œä¸­',
                'å¼€å§‹æ‰§è¡Œæ—¶é—´': int(time.time() * 1000),
            }
        })

    # æ„å»º prompt
    prompt = _build_dispatch_prompt(task, subtask_name, c_)

    result = {
        'status': 'ready',
        'recordId': record_id,
        'taskName': name,
        'priority': priority,
        'subtask': subtask_name,
        'errorCount': error_count,
        'prompt': prompt,
    }
    print(json.dumps(result, ensure_ascii=False))


def dispatch_status(args):
    """bt dispatch status â€” æ£€æŸ¥æ˜¯å¦æœ‰æ­£åœ¨è¿è¡Œçš„ dispatch sub-agent"""
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    recs = search_records(table_id, {
        'filter': {'conjunction': 'and', 'conditions': [
            {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸ”„ è¿›è¡Œä¸­']},
        ]},
        'field_names': ['ä»»åŠ¡åç§°', 'ä¼˜å…ˆçº§', 'ä»»åŠ¡è¿›å±•', 'é”™è¯¯æ¬¡æ•°'],
        'page_size': 10
    })
    if not recs:
        print(c(C.GREEN, 'âœ… æ²¡æœ‰è¿›è¡Œä¸­çš„ä»»åŠ¡'))
        return
    print(f'\n{c(C.BOLD, "ğŸ“Š è¿›è¡Œä¸­ä»»åŠ¡")}  ({len(recs)} ä¸ª)\n')
    for r in recs:
        f = r.get('fields', {})
        rid = r.get('record_id', '')
        name = fv(f, 'ä»»åŠ¡åç§°', 30)
        pri = fv(f, 'ä¼˜å…ˆçº§')
        phase = fv(f, 'ä»»åŠ¡è¿›å±•', 30)
        print(f'  {fmt_priority(pri)}  {c(C.WHITE, name)}')
        if phase:
            print(f'    {c(C.GRAY, f"ğŸ“ {phase}")}')
        print(f'    {c(C.GRAY, rid)}')


def dispatch_done(args):
    """bt dispatch done <id> <result> â€” è§£æ sub-agent ç»“æœå¹¶æ›´æ–° Base
    result å¯ä»¥æ˜¯ï¼š
    - "done" / "error" / "blocked" ï¼ˆç®€å•çŠ¶æ€ï¼‰
    - JSON å­—ç¬¦ä¸² {"status":"done","summary":"..."}
    """
    c_ = cfg()
    table_id = c_['tables']['tasks']['id']
    log_table_id = c_['tables']['logs']['id']
    record_id = args.id
    raw_result = args.result
    summary = args.summary
    subtask_name = args.subtask

    # è§£æç»“æœ
    status = 'done'
    try:
        parsed = json.loads(raw_result)
        status = parsed.get('status', 'done')
        if not summary:
            summary = parsed.get('summary', parsed.get('message', parsed.get('reason', '')))
    except (json.JSONDecodeError, TypeError):
        # ç®€å•å­—ç¬¦ä¸²ï¼šdone / error / blocked
        status = raw_result.strip().lower()
        if status not in ('done', 'error', 'blocked'):
            status = 'done'

    summary = (summary or '')[:200]

    if status == 'done':
        if subtask_name:
            # æ¨¡æ‹Ÿ subtask done
            import subprocess
            cmd = ['bt', 'subtask', 'done', record_id, subtask_name, '-s', summary or f'{subtask_name} å®Œæˆ']
            subprocess.run(cmd)
        else:
            # æ¨¡æ‹Ÿ task done
            import subprocess
            cmd = ['bt', 'task', 'done', record_id, '-s', summary, '--force']
            subprocess.run(cmd)
    elif status == 'error':
        # è®°å½•é”™è¯¯
        r = api('GET', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{record_id}')
        rec = r.get('data', {}).get('record', {})
        cur_count = int(float(fv(rec.get('fields', {}), 'é”™è¯¯æ¬¡æ•°') or '0'))
        new_count = cur_count + 1
        api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{record_id}', {
            'fields': {'é”™è¯¯æ¬¡æ•°': new_count}
        })
        # å†™ error æ—¥å¿—
        api('POST', f'/bitable/v1/apps/{c_["app_token"]}/tables/{log_table_id}/records', {
            'fields': {
                'å…³è”ä»»åŠ¡ID': record_id,
                'ç±»å‹': 'âŒ é”™è¯¯',
                'å†…å®¹': f'dispatché”™è¯¯(#{new_count})ï¼š{summary}'[:500],
            }
        })
        if new_count >= MAX_ERROR_RETRIES:
            api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{record_id}', {
                'fields': {'çŠ¶æ€': 'ğŸš§ é˜»å¡ä¸­'}
            })
            warn(f'é”™è¯¯è¾¾ä¸Šé™({new_count}/{MAX_ERROR_RETRIES})ï¼Œä»»åŠ¡å·²é˜»å¡')
        else:
            warn(f'é”™è¯¯ #{new_count}/{MAX_ERROR_RETRIES}ï¼š{summary}')
    elif status == 'blocked':
        api('PUT', f'/bitable/v1/apps/{c_["app_token"]}/tables/{table_id}/records/{record_id}', {
            'fields': {'çŠ¶æ€': 'ğŸš§ é˜»å¡ä¸­'}
        })
        # å†™é˜»å¡æ—¥å¿—
        api('POST', f'/bitable/v1/apps/{c_["app_token"]}/tables/{log_table_id}/records', {
            'fields': {
                'å…³è”ä»»åŠ¡ID': record_id,
                'ç±»å‹': 'ğŸš§ é˜»å¡',
                'å†…å®¹': f'é˜»å¡åŸå› ï¼š{summary}'[:500],
            }
        })
        warn(f'ä»»åŠ¡å·²æ ‡è®°é˜»å¡ï¼š{summary}')


# â”€â”€ MAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def main():
    parser = argparse.ArgumentParser(
        prog='bm',
        description=c(C.CYAN, 'bm â€” Base Memory CLI'),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    sub = parser.add_subparsers(dest='cmd', metavar='<å‘½ä»¤>')

    # â”€â”€ setup â”€â”€
    setup_p = sub.add_parser('setup', help='åˆå§‹åŒ–: åˆ›å»º Base è¡¨ç»“æ„å¹¶ç”Ÿæˆé…ç½®')
    setup_p.add_argument('--app-token', help='å·²æœ‰çš„å¤šç»´è¡¨æ ¼ app_tokenï¼ˆä¸ä¼ åˆ™åˆ›å»ºæ–°çš„ï¼‰')

    # â”€â”€ task â”€â”€
    task_p = sub.add_parser('task', help='ä»»åŠ¡ç®¡ç†')
    task_sub = task_p.add_subparsers(dest='action', metavar='<æ“ä½œ>')

    # task add
    p = task_sub.add_parser('add', help='æ–°å»ºä»»åŠ¡')
    p.add_argument('name', help='ä»»åŠ¡åç§°')
    p.add_argument('-p', '--priority', default='æ™®é€š', metavar='çº§åˆ«',
                   help='ç´§æ€¥|é‡è¦|æ™®é€š (é»˜è®¤:æ™®é€š)')
    p.add_argument('-i', '--instruction', default='', metavar='æŒ‡ä»¤', help='åŸå§‹æŒ‡ä»¤')
    p.add_argument('--parent', default='', metavar='çˆ¶ä»»åŠ¡ID', help='çˆ¶ä»»åŠ¡ record_idï¼ˆå­ä»»åŠ¡æ—¶ä½¿ç”¨ï¼‰')

    # task done
    p = task_sub.add_parser('done', help='æ ‡è®°å®Œæˆ')
    p.add_argument('id', help='record_id')
    p.add_argument('-t', '--tokens', type=int, default=0, metavar='N', help='Token å¼€é”€ï¼ˆæ‰‹åŠ¨æŒ‡å®šï¼‰')
    p.add_argument('--tokens-now', type=int, default=0, dest='tokens_now', metavar='N',
                   help='å½“å‰ session in-token æ€»æ•°ï¼ˆè‡ªåŠ¨ä¸å¿«ç…§åš deltaï¼‰')
    p.add_argument('-s', '--summary', default='', metavar='æ‘˜è¦', help='ç»“æœæ‘˜è¦ï¼ˆä¸€å¥è¯ï¼‰')
    p.add_argument('--force', action='store_true', help='å¼ºåˆ¶å®Œæˆï¼ˆè·³è¿‡å¾…å¼€å§‹çŠ¶æ€æ£€æŸ¥ï¼‰')

    # task up (update)
    p = task_sub.add_parser('up', help='æ›´æ–°å­—æ®µ')
    p.add_argument('id', help='record_id')
    p.add_argument('field', help='å­—æ®µåï¼ˆå¦‚ï¼šä¸‹ä¸€æ­¥è¡ŒåŠ¨ï¼‰')
    p.add_argument('value', help='æ–°å€¼')

    # task block
    p = task_sub.add_parser('block', help='æ ‡è®°é˜»å¡')
    p.add_argument('id', help='record_id')
    p.add_argument('-r', '--reason', required=True, metavar='åŸå› ', help='é˜»å¡åŸå› ')

    # task next
    p = task_sub.add_parser('next', help='è°ƒåº¦å™¨ï¼šæ¨èå½“å‰åº”è¯¥æ‰§è¡Œçš„æœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡')
    p.add_argument('-n', '--notify', action='store_true', help='æœ‰ç´§æ€¥ä»»åŠ¡æœªæ‰§è¡Œæ—¶è‡ªåŠ¨å‘é£ä¹¦é€šçŸ¥')

    # task interrupt
    p = task_sub.add_parser('interrupt', help='æ‰“æ–­å½“å‰ä»»åŠ¡ï¼Œä¿å­˜æ–­ç‚¹ï¼Œè®©ä½ç»™æ›´é«˜ä¼˜å…ˆçº§ä»»åŠ¡')
    p.add_argument('id', help='record_id')
    p.add_argument('-m', '--note', default='', metavar='æ–­ç‚¹ä¿¡æ¯', help='æ–­ç‚¹å¤‡æ³¨ï¼ˆä¸‹æ¬¡æ¢å¤æ—¶çš„æç¤ºï¼‰')

    # task ls
    p = task_sub.add_parser('ls', help='åˆ—å‡ºä»»åŠ¡')
    p.add_argument('-a', '--all', action='store_true', help='æ˜¾ç¤ºå…¨éƒ¨æœªå®Œæˆ')
    p.add_argument('-s', '--status', metavar='çŠ¶æ€', help='æŒ‰çŠ¶æ€ç­›é€‰ï¼ˆé€—å·åˆ†éš”ï¼‰')

    # task resume
    task_sub.add_parser('resume', help='é‡å¯æ¢å¤ï¼ˆè¿›è¡Œä¸­+é˜»å¡ä¸­ï¼Œå«æ–­ç‚¹ï¼‰')

    # task search
    p = task_sub.add_parser('search', help='å…³é”®è¯æœç´¢')
    p.add_argument('keyword', help='æœç´¢è¯')

    # task show
    p = task_sub.add_parser('show', help='æŸ¥çœ‹ä»»åŠ¡è¯¦æƒ…')
    p.add_argument('id', help='record_id')

    # task phase
    p = task_sub.add_parser('phase', help='æ›´æ–°ä»»åŠ¡è¿›å±•')
    p.add_argument('id', help='record_id')
    p.add_argument('phase', help='é˜¶æ®µåç§°ï¼ˆå¦‚ï¼šé˜¶æ®µ2-å®ç°ï¼‰')

    # task token-snapï¼ˆç”± agent åœ¨ bm task add åè°ƒç”¨ï¼Œå­˜ token å¿«ç…§ï¼‰
    p = task_sub.add_parser('token-snap', help='è®°å½•ä»»åŠ¡å¼€å§‹æ—¶çš„ token å¿«ç…§')
    p.add_argument('task_id', help='record_id')
    p.add_argument('in_tokens', help='å½“å‰ session in-token æ€»æ•°ï¼ˆä» session_status è¯»å–ï¼‰')

    # â”€â”€ subtask â”€â”€
    subtask_p = sub.add_parser('subtask', help='å­ä»»åŠ¡ç®¡ç†ï¼ˆå†…è”åœ¨çˆ¶ä»»åŠ¡è¡Œï¼‰')
    subtask_sub = subtask_p.add_subparsers(dest='action', metavar='<æ“ä½œ>')

    # subtask done
    p = subtask_sub.add_parser('done', help='æ ‡è®°å­ä»»åŠ¡å®Œæˆï¼ˆæ›´æ–°çˆ¶ä»»åŠ¡è¡Œå­—æ®µï¼‰')
    p.add_argument('parent_id', help='çˆ¶ä»»åŠ¡ record_id')
    p.add_argument('subtask_name', help='å­ä»»åŠ¡åç§°ï¼ˆä¸ bm task add æ—¶å®Œå…¨ä¸€è‡´ï¼‰')
    p.add_argument('-s', '--summary', default='', metavar='æ‘˜è¦', help='å®Œæˆæ‘˜è¦')

    # subtask phase
    p = subtask_sub.add_parser('phase', help='æ›´æ–°å­ä»»åŠ¡å½“å‰æ­¥éª¤ï¼ˆæ›´æ–°ã€Œä»»åŠ¡è¿›å±•ã€å­—æ®µï¼‰')
    p.add_argument('parent_id', help='çˆ¶ä»»åŠ¡ record_id')
    p.add_argument('subtask_name', help='å­ä»»åŠ¡åç§°')
    p.add_argument('step', help='å½“å‰æ­¥éª¤æè¿°ï¼Œå¦‚"é˜¶æ®µ2-ä»£ç å®ç°ï¼ˆä¸‹ä¸€æ­¥ï¼šå†™å•æµ‹ï¼‰"')

    # subtask addï¼ˆæ‰¹é‡æ·»åŠ ï¼Œæ¯”é€ä¸ª bm task add --parent èŠ‚çœ API è°ƒç”¨ï¼‰
    p = subtask_sub.add_parser('add', help='æ‰¹é‡æ·»åŠ å­ä»»åŠ¡åˆ°çˆ¶ä»»åŠ¡ï¼ˆ1æ¬¡GET+1æ¬¡PUTï¼‰')
    p.add_argument('parent_id', help='çˆ¶ä»»åŠ¡ record_id')
    p.add_argument('names', nargs='+', help='å­ä»»åŠ¡åç§°ï¼ˆå¯å¤šä¸ªï¼‰')

    # â”€â”€ log â”€â”€
    log_p = sub.add_parser('log', help='æ‰§è¡Œæ—¥å¿—ï¼ˆä¸Šä¸‹æ–‡å¸è½½ï¼‰')
    log_sub = log_p.add_subparsers(dest='action', metavar='<æ“ä½œ>')

    # log add
    p = log_sub.add_parser('add', help='å†™å…¥æ—¥å¿—æ¡ç›®')
    p.add_argument('task_id', help='å…³è”ä»»åŠ¡ record_id')
    p.add_argument('type', help='ç±»å‹: plan|finding|error|decision|milestone|progress|tool')
    p.add_argument('content', help='å†…å®¹')
    p.add_argument('--phase', default='', metavar='é˜¶æ®µ', help='ä»»åŠ¡è¿›å±•')
    p.add_argument('--attempt', type=int, default=0, metavar='N', help='å°è¯•æ¬¡æ•°ï¼ˆç”¨äºé”™è¯¯è¿½è¸ªï¼‰')
    p.add_argument('--file', default='', metavar='è·¯å¾„', help='é™„ä»¶æ–‡ä»¶è·¯å¾„ï¼ˆæˆªå›¾/å¤§æ–‡ä»¶ï¼‰')

    # log ls
    p = log_sub.add_parser('ls', help='æŸ¥çœ‹ä»»åŠ¡æ—¥å¿—')
    p.add_argument('task_id', help='å…³è”ä»»åŠ¡ record_id')
    p.add_argument('--type', default='', metavar='ç±»å‹', help='æŒ‰ç±»å‹ç­›é€‰')
    p.add_argument('--last', type=int, default=20, metavar='N', help='æœ€è¿‘Næ¡ï¼ˆé»˜è®¤20ï¼‰')

    # log search
    p = log_sub.add_parser('search', help='è·¨ä»»åŠ¡æœç´¢æ—¥å¿—ï¼ˆæœåŠ¡ç«¯æœç´¢ï¼‰')
    p.add_argument('keyword', help='æœç´¢å…³é”®è¯')
    p.add_argument('--last', type=int, default=15, metavar='N', help='æœ€å¤šè¿”å›Næ¡ï¼ˆé»˜è®¤15ï¼‰')

    # â”€â”€ mem â”€â”€
    mem_p = sub.add_parser('mem', help='è®°å¿†åº“ç®¡ç†ï¼ˆé•¿æœŸçŸ¥è¯†æ²‰æ·€ï¼‰')
    mem_sub = mem_p.add_subparsers(dest='action', metavar='<æ“ä½œ>')

    # mem add
    p = mem_sub.add_parser('add', help='å†™å…¥è®°å¿†')
    p.add_argument('title', help='æ ‡é¢˜')
    p.add_argument('content', help='å†…å®¹')
    p.add_argument('-t', '--type', default='çŸ¥è¯†', metavar='ç±»å‹',
                   help='çŸ¥è¯†|æ•™è®­|åå¥½|ä¸Šä¸‹æ–‡ (é»˜è®¤:çŸ¥è¯†)')
    p.add_argument('-i', '--importance', default='é‡è¦', metavar='é‡è¦åº¦',
                   help='æ ¸å¿ƒ|é‡è¦|æ™®é€š (é»˜è®¤:é‡è¦)')
    p.add_argument('--task', default='', metavar='ä»»åŠ¡ID', help='å…³è”ä»»åŠ¡ID')

    # mem ls
    mem_sub.add_parser('ls', help='åˆ—å‡ºæ¿€æ´»è®°å¿†')

    # mem search
    p = mem_sub.add_parser('search', help='æœç´¢è®°å¿†')
    p.add_argument('keyword', help='æœç´¢è¯')

    # â”€â”€ dispatch â”€â”€
    dispatch_p = sub.add_parser('dispatch', help='è°ƒåº¦å™¨ï¼šå‡†å¤‡ä»»åŠ¡ prompt ä¾› sessions_spawn ä½¿ç”¨')
    dispatch_sub = dispatch_p.add_subparsers(dest='action', metavar='<æ“ä½œ>')

    # dispatch prep â€” è·å–ä¸‹ä¸€ä¸ªä»»åŠ¡å¹¶æ„å»º prompt
    p = dispatch_sub.add_parser('prep', help='å‡†å¤‡ä¸‹ä¸€ä¸ªä»»åŠ¡çš„ promptï¼ˆJSON è¾“å‡ºï¼‰')
    p.add_argument('--json', action='store_true', dest='json_output', help='çº¯ JSON è¾“å‡ºï¼ˆä¾›ç¨‹åºè°ƒç”¨ï¼‰')

    # dispatch done â€” è§£æ sub-agent ç»“æœå¹¶æ›´æ–° Base
    p = dispatch_sub.add_parser('done', help='è§£ææ‰§è¡Œç»“æœå¹¶æ›´æ–° Base')
    p.add_argument('id', help='record_id')
    p.add_argument('result', help='ç»“æœ JSON å­—ç¬¦ä¸² æˆ– "done"/"error"/"blocked"')
    p.add_argument('-s', '--summary', default='', metavar='æ‘˜è¦', help='ç»“æœæ‘˜è¦')
    p.add_argument('--subtask', default='', metavar='å­ä»»åŠ¡å', help='å­ä»»åŠ¡åç§°ï¼ˆæœ‰å­ä»»åŠ¡æ—¶ï¼‰')

    # dispatch status â€” æŸ¥çœ‹è¿›è¡Œä¸­ä»»åŠ¡
    dispatch_sub.add_parser('status', help='æŸ¥çœ‹è¿›è¡Œä¸­ä»»åŠ¡çŠ¶æ€')

    # â”€â”€ è·¯ç”± â”€â”€
    args = parser.parse_args()

    if args.cmd == 'setup':
        import subprocess
        setup_script = os.path.join(SCRIPT_DIR, 'bt_setup.py')
        cmd = [sys.executable, setup_script]
        if args.app_token:
            cmd.extend(['--app-token', args.app_token])
        sys.exit(subprocess.call(cmd))

    if args.cmd == 'task':
        if not args.action:   task_p.print_help(); return
        dispatch = {
            'add': task_add, 'done': task_done, 'up': task_update,
            'block': task_block, 'interrupt': task_interrupt, 'next': task_next,
            'ls': task_ls, 'resume': task_resume,
            'search': task_search, 'show': task_show, 'phase': task_phase,
            'token-snap': task_token_snap,
        }
        dispatch.get(args.action, lambda a: task_p.print_help())(args)

    elif args.cmd == 'subtask':
        if not args.action:   subtask_p.print_help(); return
        dispatch = {'done': subtask_done, 'phase': subtask_phase, 'add': subtask_add_batch}
        dispatch.get(args.action, lambda a: subtask_p.print_help())(args)

    elif args.cmd == 'log':
        if not args.action:   log_p.print_help(); return
        dispatch = {'add': log_add, 'ls': log_ls, 'search': log_search}
        dispatch.get(args.action, lambda a: log_p.print_help())(args)

    elif args.cmd == 'mem':
        if not args.action:   mem_p.print_help(); return
        dispatch = {'add': mem_add, 'ls': mem_ls, 'search': mem_search}
        dispatch.get(args.action, lambda a: mem_p.print_help())(args)

    elif args.cmd == 'dispatch':
        if not args.action:   dispatch_p.print_help(); return
        dispatch = {'prep': dispatch_prep, 'done': dispatch_done, 'status': dispatch_status}
        dispatch.get(args.action, lambda a: dispatch_p.print_help())(args)

    else:
        # æ— å‚æ•°æ—¶æ˜¾ç¤ºå¸®åŠ© + å½“å‰çŠ¶æ€
        print(f'\n{c(C.BOLD+C.CYAN, "ğŸ¦ bm â€” Base Memory CLI")}\n')
        print(f'  {c(C.GRAY, "ä»»åŠ¡:    bm task add|done|up|block|interrupt|next|ls|resume|search|show|phase")}')
        subtask_hint = 'å­ä»»åŠ¡:  bm subtask done|phase <çˆ¶ID> "å­ä»»åŠ¡å"  ï¼ˆå†…è”åœ¨çˆ¶ä»»åŠ¡è¡Œï¼‰'
        print(f'  {c(C.GRAY, subtask_hint)}')
        print(f'  {c(C.GRAY, "æ—¥å¿—:    bm log add|ls|search  ï¼ˆä¸Šä¸‹æ–‡å¸è½½ + è·¨ä»»åŠ¡æœç´¢ï¼‰")}')
        print(f'  {c(C.GRAY, "è®°å¿†:    bm mem add|ls|search  ï¼ˆé•¿æœŸçŸ¥è¯†æ²‰æ·€ï¼‰")}')
        
        print(f'  {c(C.GRAY, "æ–‡æ¡£:  https://github.com/dsjgudfiufr/base-memory")}\n')
        # å¿«é€Ÿæ˜¾ç¤ºè¿›è¡Œä¸­ä»»åŠ¡æ•°
        try:
            c_ = cfg()
            table_id = c_['tables']['tasks']['id']
            recs = search_records(table_id, {
                'filter': {'conjunction': 'or', 'conditions': [
                    {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸ”„ è¿›è¡Œä¸­']},
                    {'field_name': 'çŠ¶æ€', 'operator': 'is', 'value': ['ğŸš§ é˜»å¡ä¸­']},
                ]}
            })
            if recs:
                print(f'  {c(C.YELLOW, f"âš¡ å½“å‰æœ‰ {len(recs)} ä¸ªä»»åŠ¡è¿›è¡Œä¸­ï¼Œè¿è¡Œ bm task resume æŸ¥çœ‹")}\n')
        except:
            pass

if __name__ == '__main__':
    main()
